Microsoft (R) Macro Assembler Version 14.16.27027.1	    05/03/19 11:26:49
AddTwo.asm						     Page 1 - 1


				include irvine32.inc
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C 
			      C ;OPTION CASEMAP:NONE		; optional: make identifiers case-sensitive
			      C 
			      C INCLUDE SmallWin.inc		; MS-Windows prototypes, structures, and constants
			      C .NOLIST
			      C .LIST
			      C 
			      C INCLUDE VirtualKeys.inc
			      C ; VirtualKeys.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C .NOLIST
			      C .LIST
			      C 
				include  macros.inc
			      C .NOLIST
			      C .LIST
			      C 

 00000000			.data
 00000000 00000000		var1 dword ?
 00000004 00000000		var2 dword ?
 00000008 00000000		var3 dword ?
 0000000C 00000000		var4 dword ?
 00000010 00000000		var5 dword ?
 00000014 00000000		var6 dword ?
 00000018 00000000		var7 dword ?
 0000001C 00000000		var8 dword ?
 00000020 00000000		var9 dword ?
 00000024 00000000		matrixb1 dword ? 
 00000028 00000000		matrixb2 dword ?
 0000002C 00000000		matrixb3 dword ?
 00000030 00000000		temprary dword ? 
 00000034 09 09 09 09 57	Menu byte "				What do you want to do:",0ah,0dh
	   68 61 74 20 64
	   6F 20 79 6F 75
	   20 77 61 6E 74
	   20 74 6F 20 64
	   6F 3A 0A 0D
 00000051  09 09 09 09 2D		 byte "				-----------------------",0ah,0dh
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 0A 0D
 0000006E  09 09 09 09 31		 byte "				1-Addtion of Matrices" ,0ah,0dh
	   2D 41 64 64 74
	   69 6F 6E 20 6F
	   66 20 4D 61 74
	   72 69 63 65 73
	   0A 0D
 00000089  09 09 09 09 32		 byte "				2-Subtraction of Matrices",0ah,0dh
	   2D 53 75 62 74
	   72 61 63 74 69
	   6F 6E 20 6F 66
	   20 4D 61 74 72
	   69 63 65 73 0A
	   0D
 000000A8  09 09 09 09 33		 byte "				3-AdjOf of a Matrix",0ah,0dh
	   2D 41 64 6A 4F
	   66 20 6F 66 20
	   61 20 4D 61 74
	   72 69 78 0A 0D
 000000C1  09 09 09 09 34		 byte "				4-Determinent (Mod) of a matrix",0ah,0dh
	   2D 44 65 74 65
	   72 6D 69 6E 65
	   6E 74 20 28 4D
	   6F 64 29 20 6F
	   66 20 61 20 6D
	   61 74 72 69 78
	   0A 0D
 000000E6  09 09 09 09 35		 byte "				5-Transpose of a matrix",0ah,0dh
	   2D 54 72 61 6E
	   73 70 6F 73 65
	   20 6F 66 20 61
	   20 6D 61 74 72
	   69 78 0A 0D
 00000103  09 09 09 09 36		 byte "				6-Multiplication of a Matrices",0ah,0dh
	   2D 4D 75 6C 74
	   69 70 6C 69 63
	   61 74 69 6F 6E
	   20 6F 66 20 61
	   20 4D 61 74 72
	   69 63 65 73 0A
	   0D
 00000127  09 09 09 09 37		 byte "				7-Inverse of a Matrix",0ah,0dh
	   2D 49 6E 76 65
	   72 73 65 20 6F
	   66 20 61 20 4D
	   61 74 72 69 78
	   0A 0D
 00000142  09 09 09 09 38		 byte "				8-System Of Linear Equations:",0ah,0dh,0
	   2D 53 79 73 74
	   65 6D 20 4F 66
	   20 4C 69 6E 65
	   61 72 20 45 71
	   75 61 74 69 6F
	   6E 73 3A 0A 0D
	   00

 00000166 50 52 45 53 53	selectString byte "PRESS THE KEY:",0ah,0dh
	   20 54 48 45 20
	   4B 45 59 3A 0A
	   0D
 00000176  09 09 09 31 2E		byte "			1.For 1X1 Matrix",0ah,0dh
	   46 6F 72 20 31
	   58 31 20 4D 61
	   74 72 69 78 0A
	   0D
 0000018B  09 09 09 32 2E		byte "			2.For 1X2 Matrix",0ah,0dh
	   46 6F 72 20 31
	   58 32 20 4D 61
	   74 72 69 78 0A
	   0D
 000001A0  09 09 09 33 2E		byte "			3.For 1X3 Matrix",0ah,0dh
	   46 6F 72 20 31
	   58 33 20 4D 61
	   74 72 69 78 0A
	   0D
 000001B5  09 09 09 34 2E		byte "			4.For 2X1 Matrix",0ah,0dh
	   46 6F 72 20 32
	   58 31 20 4D 61
	   74 72 69 78 0A
	   0D
 000001CA  09 09 09 35 2E		byte "			5.For 2X2 Matrix",0ah,0dh
	   46 6F 72 20 32
	   58 32 20 4D 61
	   74 72 69 78 0A
	   0D
 000001DF  09 09 09 36 2E		byte "			6.For 2X3 Matrix",0ah,0dh
	   46 6F 72 20 32
	   58 33 20 4D 61
	   74 72 69 78 0A
	   0D
 000001F4  09 09 09 37 2E		byte "			7.For 3X1 Matrix",0ah,0dh
	   46 6F 72 20 33
	   58 31 20 4D 61
	   74 72 69 78 0A
	   0D
 00000209  09 09 09 38 2E		byte "			8.For 3X2 Matrix",0ah,0dh
	   46 6F 72 20 33
	   58 32 20 4D 61
	   74 72 69 78 0A
	   0D
 0000021E  09 09 09 39 2E		byte "			9.For 3X3 Matrix",0ah,0dh,0
	   46 6F 72 20 33
	   58 33 20 4D 61
	   74 72 69 78 0A
	   0D 00

 00000234  00000009 [		arr dword  9 dup(?)
	    00000000
	   ]
 00000258  00000009 [		arr1 dword  9 dup(?)
	    00000000
	   ]

 00000000			.code

 00000000			mainLabel: ;label for jumping to main proc, if user press 1 after the end of each procedure

 00000000			main proc
 00000000  E8 00000000 E	    call crlf
 00000005  BA 00000034 R		mov edx,offset Menu
 0000000A  E8 00000000 E		call writestring
 0000000F  E8 00000000 E		call crlf
					mwrite<"Enter your choice << ",0>
 0000027C		     1		.data		
 0000027C 45 6E 74 65 72     1		??0000 BYTE "Enter your choice << ",0,0	
	   20 79 6F 75 72
	   20 63 68 6F 69
	   63 65 20 3C 3C
	   20 00 00
 00000014		     1		.code
 00000014  52		     1		push	edx
 00000015  BA 0000027C R     1		mov	edx,OFFSET ??0000
 0000001A  E8 00000000 E     1		call	WriteString
 0000001F  5A		     1		pop	edx
 00000020  E8 00000000 E		call readint 
					mwrite<"----------------------",0ah,0dh>
 00000293		     1		.data		
 00000293 2D 2D 2D 2D 2D     1		??0001 BYTE "----------------------",0ah,0dh,0	
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 0A 0D 00
 00000025		     1		.code
 00000025  52		     1		push	edx
 00000026  BA 00000293 R     1		mov	edx,OFFSET ??0001
 0000002B  E8 00000000 E     1		call	WriteString
 00000030  5A		     1		pop	edx

					.if eax==1
 00000031  83 F8 01	   *	    cmp    eax, 001h
 00000034  75 07	   *	    jne    @C0001
 00000036  E8 0000007B			call Sum
					.elseif eax==2
 0000003B  EB 52	   *	    jmp    @C0003
 0000003D		   *@C0001:
 0000003D  83 F8 02	   *	    cmp    eax, 002h
 00000040  75 07	   *	    jne    @C0004
 00000042  E8 00000657			call Subtraction
					.elseif  eax==3
 00000047  EB 46	   *	    jmp    @C0006
 00000049		   *@C0004:
 00000049  83 F8 03	   *	    cmp    eax, 003h
 0000004C  75 07	   *	    jne    @C0007
 0000004E  E8 00000C33			call AdjOf
					.elseif eax==4
 00000053  EB 3A	   *	    jmp    @C0009
 00000055		   *@C0007:
 00000055  83 F8 04	   *	    cmp    eax, 004h
 00000058  75 07	   *	    jne    @C000A
 0000005A  E8 00000F8E			call ModOf
					.elseif eax==5
 0000005F  EB 2E	   *	    jmp    @C000C
 00000061		   *@C000A:
 00000061  83 F8 05	   *	    cmp    eax, 005h
 00000064  75 07	   *	    jne    @C000D
 00000066  E8 0000113A			call Transpose
					.elseif eax==6
 0000006B  EB 22	   *	    jmp    @C000F
 0000006D		   *@C000D:
 0000006D  83 F8 06	   *	    cmp    eax, 006h
 00000070  75 07	   *	    jne    @C0010
 00000072  E8 0000163B			call Multiplication
					.elseif eax==7
 00000077  EB 16	   *	    jmp    @C0012
 00000079		   *@C0010:
 00000079  83 F8 07	   *	    cmp    eax, 007h
 0000007C  75 07	   *	    jne    @C0013
 0000007E  E8 00001AE7			call Inverse
					.elseif eax==8
 00000083  EB 0A	   *	    jmp    @C0015
 00000085		   *@C0013:
 00000085  83 F8 08	   *	    cmp    eax, 008h
 00000088  75 05	   *	    jne    @C0016
 0000008A  E8 00001FB7			call SystemOfLinearEquations
					.endif
 0000008F		   *@C0016:
 0000008F		   *@C0015:
 0000008F		   *@C0012:
 0000008F		   *@C000F:
 0000008F		   *@C000C:
 0000008F		   *@C0009:
 0000008F		   *@C0006:
 0000008F		   *@C0003:
					
 0000008F  E8 00000000 E		call crlf
					mwrite<"Enter 0 to Exit, 1 to proceed << ",0>
 000002AC		     1		.data		
 000002AC 45 6E 74 65 72     1		??0002 BYTE "Enter 0 to Exit, 1 to proceed << ",0,0	
	   20 30 20 74 6F
	   20 45 78 69 74
	   2C 20 31 20 74
	   6F 20 70 72 6F
	   63 65 65 64 20
	   3C 3C 20 00 00
 00000094		     1		.code
 00000094  52		     1		push	edx
 00000095  BA 000002AC R     1		mov	edx,OFFSET ??0002
 0000009A  E8 00000000 E     1		call	WriteString
 0000009F  5A		     1		pop	edx
 000000A0  E8 00000000 E		call readint
					.if eax==1
 000000A5  83 F8 01	   *	    cmp    eax, 001h
 000000A8  75 05	   *	    jne    @C0018
 000000AA  E9 FFFFFF51			jmp mainLabel
					.endif
 000000AF		   *@C0018:

				exit 
 000000AF  6A 00	   *	    push   +000000000h
 000000B1  E8 00000000 E   *	    call   ExitProcess
 000000B6			main endp

				;procedure to sum the Matrix elements
 000000B6			Sum PROC
 000000B6  E8 00000000 E		call crlf
 000000BB  BA 00000166 R		mov edx,offset selectString
 000000C0  E8 00000000 E		call writestring
 000000C5  E8 00000000 E		call crlf
					mwrite<"Enter your choice << ",0>
 000002CF		     1		.data		
 000002CF 45 6E 74 65 72     1		??0003 BYTE "Enter your choice << ",0,0	
	   20 79 6F 75 72
	   20 63 68 6F 69
	   63 65 20 3C 3C
	   20 00 00
 000000CA		     1		.code
 000000CA  52		     1		push	edx
 000000CB  BA 000002CF R     1		mov	edx,OFFSET ??0003
 000000D0  E8 00000000 E     1		call	WriteString
 000000D5  5A		     1		pop	edx
 000000D6  E8 00000000 E		call readint 
					mwrite<"----------------------",0ah,0dh>

 000002E6		     1		.data		
 000002E6 2D 2D 2D 2D 2D     1		??0004 BYTE "----------------------",0ah,0dh,0	
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 0A 0D 00
 000000DB		     1		.code
 000000DB  52		     1		push	edx
 000000DC  BA 000002E6 R     1		mov	edx,OFFSET ??0004
 000000E1  E8 00000000 E     1		call	WriteString
 000000E6  5A		     1		pop	edx
					.if eax==1
 000000E7  83 F8 01	   *	    cmp    eax, 001h
 000000EA  75 04	   *	    jne    @C001A
 000000EC  EB 60			jmp case1
					.elseif eax==2
 000000EE  EB 5E	   *	    jmp    @C001C
 000000F0		   *@C001A:
 000000F0  83 F8 02	   *	    cmp    eax, 002h
 000000F3  75 07	   *	    jne    @C001D
 000000F5  E9 000000DD			jmp case2
					.elseif  eax==3
 000000FA  EB 52	   *	    jmp    @C001F
 000000FC		   *@C001D:
 000000FC  83 F8 03	   *	    cmp    eax, 003h
 000000FF  75 07	   *	    jne    @C0020
 00000101  E9 0000015A			jmp case3
					.elseif eax==4
 00000106  EB 46	   *	    jmp    @C0022
 00000108		   *@C0020:
 00000108  83 F8 04	   *	    cmp    eax, 004h
 0000010B  75 07	   *	    jne    @C0023
 0000010D  E9 000001D7			jmp case4
					.elseif eax==5
 00000112  EB 3A	   *	    jmp    @C0025
 00000114		   *@C0023:
 00000114  83 F8 05	   *	    cmp    eax, 005h
 00000117  75 07	   *	    jne    @C0026
 00000119  E9 00000265			jmp case5
					.elseif eax==6
 0000011E  EB 2E	   *	    jmp    @C0028
 00000120		   *@C0026:
 00000120  83 F8 06	   *	    cmp    eax, 006h
 00000123  75 07	   *	    jne    @C0029
 00000125  E9 000002F3			jmp case6
					.elseif eax==7
 0000012A  EB 22	   *	    jmp    @C002B
 0000012C		   *@C0029:
 0000012C  83 F8 07	   *	    cmp    eax, 007h
 0000012F  75 07	   *	    jne    @C002C
 00000131  E9 00000381			jmp case7
					.elseif eax==8
 00000136  EB 16	   *	    jmp    @C002E
 00000138		   *@C002C:
 00000138  83 F8 08	   *	    cmp    eax, 008h
 0000013B  75 07	   *	    jne    @C002F
 0000013D  E9 00000414			jmp case8
					.elseif eax==9
 00000142  EB 0A	   *	    jmp    @C0031
 00000144		   *@C002F:
 00000144  83 F8 09	   *	    cmp    eax, 009h
 00000147  75 05	   *	    jne    @C0032
 00000149  E9 000004A7			jmp case9
					.endif
 0000014E		   *@C0032:
 0000014E		   *@C0031:
 0000014E		   *@C002E:
 0000014E		   *@C002B:
 0000014E		   *@C0028:
 0000014E		   *@C0025:
 0000014E		   *@C0022:
 0000014E		   *@C001F:
 0000014E		   *@C001C:
 0000014E				case1:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 000002FF		     1		.data		
 000002FF 45 6E 74 65 72     1		??0005 BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 0000014E		     1		.code
 0000014E  52		     1		push	edx
 0000014F  BA 000002FF R     1		mov	edx,OFFSET ??0005
 00000154  E8 00000000 E     1		call	WriteString
 00000159  5A		     1		pop	edx
 0000015A  BE 00000000				mov esi,0
 0000015F  B9 00000001				mov ecx,1
 00000164					L11:
 00000164  E8 00000000 E				call readint
 00000169  89 86 00000234 R				mov arr[esi],eax
 0000016F  83 C6 04					add esi,type arr
 00000172  E2 F0				loop L11

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 00000322		     1		.data		
 00000322 45 6E 74 65 72     1		??0006 BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 00000174		     1		.code
 00000174  52		     1		push	edx
 00000175  BA 00000322 R     1		mov	edx,OFFSET ??0006
 0000017A  E8 00000000 E     1		call	WriteString
 0000017F  5A		     1		pop	edx
 00000180  BE 00000000				mov esi,0
 00000185  B9 00000001				mov ecx,1
 0000018A					L12:
 0000018A  E8 00000000 E				call readint
 0000018F  89 86 00000258 R				mov arr1[esi],eax
 00000195  83 C6 04					add esi,type arr1
 00000198  E2 F0				loop L12

						mwrite<"The sum of both matrices is",0ah,0dh,0>
 00000345		     1		.data		
 00000345 54 68 65 20 73     1		??0007 BYTE "The sum of both matrices is",0ah,0dh,0,0	
	   75 6D 20 6F 66
	   20 62 6F 74 68
	   20 6D 61 74 72
	   69 63 65 73 20
	   69 73 0A 0D 00
	   00
 0000019A		     1		.code
 0000019A  52		     1		push	edx
 0000019B  BA 00000345 R     1		mov	edx,OFFSET ??0007
 000001A0  E8 00000000 E     1		call	WriteString
 000001A5  5A		     1		pop	edx
 000001A6  B9 00000001				mov ecx,1
 000001AB  BE 00000000				mov esi,0
 000001B0					L13:
 000001B0  8B 86 00000234 R				mov eax,arr[esi]
 000001B6  03 86 00000258 R				add eax,arr1[esi]
							mwrite<"	",0>
 00000364		     1		.data		
 00000364 09 00 00	     1		??0008 BYTE "	",0,0	
 000001BC		     1		.code
 000001BC  52		     1		push	edx
 000001BD  BA 00000364 R     1		mov	edx,OFFSET ??0008
 000001C2  E8 00000000 E     1		call	WriteString
 000001C7  5A		     1		pop	edx
 000001C8  E8 00000000 E				call writeint
 000001CD  83 C6 04					add esi,type arr1
 000001D0  E2 DE				loop L13
 000001D2  E9 000004C6				jmp LExit
 000001D7				case2:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 00000367		     1		.data		
 00000367 45 6E 74 65 72     1		??0009 BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 000001D7		     1		.code
 000001D7  52		     1		push	edx
 000001D8  BA 00000367 R     1		mov	edx,OFFSET ??0009
 000001DD  E8 00000000 E     1		call	WriteString
 000001E2  5A		     1		pop	edx
 000001E3  BE 00000000				mov esi,0
 000001E8  B9 00000002				mov ecx,2
 000001ED					L21:
 000001ED  E8 00000000 E				call readint
 000001F2  89 86 00000234 R				mov arr[esi],eax
 000001F8  83 C6 04					add esi,type arr
 000001FB  E2 F0				loop L21

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 0000038A		     1		.data		
 0000038A 45 6E 74 65 72     1		??000A BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 000001FD		     1		.code
 000001FD  52		     1		push	edx
 000001FE  BA 0000038A R     1		mov	edx,OFFSET ??000A
 00000203  E8 00000000 E     1		call	WriteString
 00000208  5A		     1		pop	edx
 00000209  BE 00000000				mov esi,0
 0000020E  B9 00000002				mov ecx,2
 00000213					L22:
 00000213  E8 00000000 E				call readint
 00000218  89 86 00000258 R				mov arr1[esi],eax
 0000021E  83 C6 04					add esi,type arr1
 00000221  E2 F0				loop L22

						mwrite<"The sum of both matrices is",0ah,0dh,0>
 000003AD		     1		.data		
 000003AD 54 68 65 20 73     1		??000B BYTE "The sum of both matrices is",0ah,0dh,0,0	
	   75 6D 20 6F 66
	   20 62 6F 74 68
	   20 6D 61 74 72
	   69 63 65 73 20
	   69 73 0A 0D 00
	   00
 00000223		     1		.code
 00000223  52		     1		push	edx
 00000224  BA 000003AD R     1		mov	edx,OFFSET ??000B
 00000229  E8 00000000 E     1		call	WriteString
 0000022E  5A		     1		pop	edx
 0000022F  B9 00000002				mov ecx,2
 00000234  BE 00000000				mov esi,0
 00000239					L23:
 00000239  8B 86 00000234 R				mov eax,arr[esi]
 0000023F  03 86 00000258 R				add eax,arr1[esi]
							mwrite<"	",0>
 000003CC		     1		.data		
 000003CC 09 00 00	     1		??000C BYTE "	",0,0	
 00000245		     1		.code
 00000245  52		     1		push	edx
 00000246  BA 000003CC R     1		mov	edx,OFFSET ??000C
 0000024B  E8 00000000 E     1		call	WriteString
 00000250  5A		     1		pop	edx
 00000251  E8 00000000 E				call writeint
 00000256  83 C6 04					add esi,type arr1
 00000259  E2 DE				loop L23
 0000025B  E9 0000043D				jmp LExit
 00000260				case3:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 000003CF		     1		.data		
 000003CF 45 6E 74 65 72     1		??000D BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 00000260		     1		.code
 00000260  52		     1		push	edx
 00000261  BA 000003CF R     1		mov	edx,OFFSET ??000D
 00000266  E8 00000000 E     1		call	WriteString
 0000026B  5A		     1		pop	edx
 0000026C  BE 00000000				mov esi,0
 00000271  B9 00000003				mov ecx,3
 00000276					L31:
 00000276  E8 00000000 E				call readint
 0000027B  89 86 00000234 R				mov arr[esi],eax
 00000281  83 C6 04					add esi,type arr
 00000284  E2 F0				loop L31

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 000003F2		     1		.data		
 000003F2 45 6E 74 65 72     1		??000E BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 00000286		     1		.code
 00000286  52		     1		push	edx
 00000287  BA 000003F2 R     1		mov	edx,OFFSET ??000E
 0000028C  E8 00000000 E     1		call	WriteString
 00000291  5A		     1		pop	edx
 00000292  BE 00000000				mov esi,0
 00000297  B9 00000003				mov ecx,3
 0000029C					L32:
 0000029C  E8 00000000 E				call readint
 000002A1  89 86 00000258 R				mov arr1[esi],eax
 000002A7  83 C6 04					add esi,type arr1
 000002AA  E2 F0				loop L32

						mwrite<"The sum of both matrices is",0ah,0dh,0>
 00000415		     1		.data		
 00000415 54 68 65 20 73     1		??000F BYTE "The sum of both matrices is",0ah,0dh,0,0	
	   75 6D 20 6F 66
	   20 62 6F 74 68
	   20 6D 61 74 72
	   69 63 65 73 20
	   69 73 0A 0D 00
	   00
 000002AC		     1		.code
 000002AC  52		     1		push	edx
 000002AD  BA 00000415 R     1		mov	edx,OFFSET ??000F
 000002B2  E8 00000000 E     1		call	WriteString
 000002B7  5A		     1		pop	edx
 000002B8  B9 00000003				mov ecx,3
 000002BD  BE 00000000				mov esi,0
 000002C2					L33:
 000002C2  8B 86 00000234 R				mov eax,arr[esi]
 000002C8  03 86 00000258 R				add eax,arr1[esi]
							mwrite<"	",0>
 00000434		     1		.data		
 00000434 09 00 00	     1		??0010 BYTE "	",0,0	
 000002CE		     1		.code
 000002CE  52		     1		push	edx
 000002CF  BA 00000434 R     1		mov	edx,OFFSET ??0010
 000002D4  E8 00000000 E     1		call	WriteString
 000002D9  5A		     1		pop	edx
 000002DA  E8 00000000 E				call writeint
 000002DF  83 C6 04					add esi,type arr1
 000002E2  E2 DE				loop L33
 000002E4  E9 000003B4				jmp LExit

 000002E9				case4:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 00000437		     1		.data		
 00000437 45 6E 74 65 72     1		??0011 BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 000002E9		     1		.code
 000002E9  52		     1		push	edx
 000002EA  BA 00000437 R     1		mov	edx,OFFSET ??0011
 000002EF  E8 00000000 E     1		call	WriteString
 000002F4  5A		     1		pop	edx
 000002F5  BE 00000000				mov esi,0
 000002FA  B9 00000002				mov ecx,2
 000002FF					L41:
 000002FF  E8 00000000 E				call readint
 00000304  89 86 00000234 R				mov arr[esi],eax
 0000030A  83 C6 04					add esi,type arr
 0000030D  E2 F0				loop L41

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 0000045A		     1		.data		
 0000045A 45 6E 74 65 72     1		??0012 BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 0000030F		     1		.code
 0000030F  52		     1		push	edx
 00000310  BA 0000045A R     1		mov	edx,OFFSET ??0012
 00000315  E8 00000000 E     1		call	WriteString
 0000031A  5A		     1		pop	edx
 0000031B  BE 00000000				mov esi,0
 00000320  B9 00000002				mov ecx,2
 00000325					L42:
 00000325  E8 00000000 E				call readint
 0000032A  89 86 00000258 R				mov arr1[esi],eax
 00000330  83 C6 04					add esi,type arr1
 00000333  E2 F0				loop L42

						mwrite<"The sum of both matrices is",0ah,0dh,0>
 0000047D		     1		.data		
 0000047D 54 68 65 20 73     1		??0013 BYTE "The sum of both matrices is",0ah,0dh,0,0	
	   75 6D 20 6F 66
	   20 62 6F 74 68
	   20 6D 61 74 72
	   69 63 65 73 20
	   69 73 0A 0D 00
	   00
 00000335		     1		.code
 00000335  52		     1		push	edx
 00000336  BA 0000047D R     1		mov	edx,OFFSET ??0013
 0000033B  E8 00000000 E     1		call	WriteString
 00000340  5A		     1		pop	edx
 00000341  B9 00000002				mov ecx,2
 00000346  BE 00000000				mov esi,0
 0000034B					L43:
 0000034B  8B 86 00000234 R				mov eax,arr[esi]
 00000351  03 86 00000258 R				add eax,arr1[esi]
							.if ecx==1
 00000357  83 F9 01	   *	    cmp    ecx, 001h
 0000035A  75 0C	   *	    jne    @C0034
							mwrite<"	",0ah,0dh,0>
 0000049C		     1		.data		
 0000049C 09 0A 0D 00 00     1		??0014 BYTE "	",0ah,0dh,0,0	
 0000035C		     1		.code
 0000035C  52		     1		push	edx
 0000035D  BA 0000049C R     1		mov	edx,OFFSET ??0014
 00000362  E8 00000000 E     1		call	WriteString
 00000367  5A		     1		pop	edx
							.endif
 00000368		   *@C0034:
							mwrite<"	",0>
 000004A1		     1		.data		
 000004A1 09 00 00	     1		??0015 BYTE "	",0,0	
 00000368		     1		.code
 00000368  52		     1		push	edx
 00000369  BA 000004A1 R     1		mov	edx,OFFSET ??0015
 0000036E  E8 00000000 E     1		call	WriteString
 00000373  5A		     1		pop	edx
 00000374  E8 00000000 E				call writeint
 00000379  83 C6 04					add esi,type arr1
 0000037C  E2 CD				loop L43
 0000037E  E9 0000031A				jmp LExit
 00000383				case5:
					mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 000004A4		     1		.data		
 000004A4 45 6E 74 65 72     1		??0016 BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 00000383		     1		.code
 00000383  52		     1		push	edx
 00000384  BA 000004A4 R     1		mov	edx,OFFSET ??0016
 00000389  E8 00000000 E     1		call	WriteString
 0000038E  5A		     1		pop	edx
 0000038F  BE 00000000				mov esi,0
 00000394  B9 00000004				mov ecx,4
 00000399					L51:
 00000399  E8 00000000 E				call readint
 0000039E  89 86 00000234 R				mov arr[esi],eax
 000003A4  83 C6 04					add esi,type arr
 000003A7  E2 F0				loop L51

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 000004C7		     1		.data		
 000004C7 45 6E 74 65 72     1		??0017 BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 000003A9		     1		.code
 000003A9  52		     1		push	edx
 000003AA  BA 000004C7 R     1		mov	edx,OFFSET ??0017
 000003AF  E8 00000000 E     1		call	WriteString
 000003B4  5A		     1		pop	edx
 000003B5  BE 00000000				mov esi,0
 000003BA  B9 00000004				mov ecx,4
 000003BF					L52:
 000003BF  E8 00000000 E				call readint
 000003C4  89 86 00000258 R				mov arr1[esi],eax
 000003CA  83 C6 04					add esi,type arr1
 000003CD  E2 F0				loop L52

						mwrite<"The sum of both matrices is",0ah,0dh,0>
 000004EA		     1		.data		
 000004EA 54 68 65 20 73     1		??0018 BYTE "The sum of both matrices is",0ah,0dh,0,0	
	   75 6D 20 6F 66
	   20 62 6F 74 68
	   20 6D 61 74 72
	   69 63 65 73 20
	   69 73 0A 0D 00
	   00
 000003CF		     1		.code
 000003CF  52		     1		push	edx
 000003D0  BA 000004EA R     1		mov	edx,OFFSET ??0018
 000003D5  E8 00000000 E     1		call	WriteString
 000003DA  5A		     1		pop	edx
 000003DB  B9 00000004				mov ecx,4
 000003E0  BE 00000000				mov esi,0
 000003E5					L53:
 000003E5  8B 86 00000234 R				mov eax,arr[esi]
 000003EB  03 86 00000258 R				add eax,arr1[esi]
							.if ecx==2
 000003F1  83 F9 02	   *	    cmp    ecx, 002h
 000003F4  75 0C	   *	    jne    @C0036
							mwrite<"	",0ah,0dh,0>
 00000509		     1		.data		
 00000509 09 0A 0D 00 00     1		??0019 BYTE "	",0ah,0dh,0,0	
 000003F6		     1		.code
 000003F6  52		     1		push	edx
 000003F7  BA 00000509 R     1		mov	edx,OFFSET ??0019
 000003FC  E8 00000000 E     1		call	WriteString
 00000401  5A		     1		pop	edx
							.endif
 00000402		   *@C0036:
							mwrite<"	",0>
 0000050E		     1		.data		
 0000050E 09 00 00	     1		??001A BYTE "	",0,0	
 00000402		     1		.code
 00000402  52		     1		push	edx
 00000403  BA 0000050E R     1		mov	edx,OFFSET ??001A
 00000408  E8 00000000 E     1		call	WriteString
 0000040D  5A		     1		pop	edx
 0000040E  E8 00000000 E				call writeint
 00000413  83 C6 04					add esi,type arr1
 00000416  E2 CD				loop L53
 00000418  E9 00000280				jmp LExit

 0000041D				case6:
					mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 00000511		     1		.data		
 00000511 45 6E 74 65 72     1		??001B BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 0000041D		     1		.code
 0000041D  52		     1		push	edx
 0000041E  BA 00000511 R     1		mov	edx,OFFSET ??001B
 00000423  E8 00000000 E     1		call	WriteString
 00000428  5A		     1		pop	edx
 00000429  BE 00000000				mov esi,0
 0000042E  B9 00000006				mov ecx,6
 00000433					L61:
 00000433  E8 00000000 E				call readint
 00000438  89 86 00000234 R				mov arr[esi],eax
 0000043E  83 C6 04					add esi,type arr
 00000441  E2 F0				loop L61

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 00000534		     1		.data		
 00000534 45 6E 74 65 72     1		??001C BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 00000443		     1		.code
 00000443  52		     1		push	edx
 00000444  BA 00000534 R     1		mov	edx,OFFSET ??001C
 00000449  E8 00000000 E     1		call	WriteString
 0000044E  5A		     1		pop	edx
 0000044F  BE 00000000				mov esi,0
 00000454  B9 00000006				mov ecx,6
 00000459					L62:
 00000459  E8 00000000 E				call readint
 0000045E  89 86 00000258 R				mov arr1[esi],eax
 00000464  83 C6 04					add esi,type arr1
 00000467  E2 F0				loop L62

						mwrite<"The sum of both matrices is",0ah,0dh,0>
 00000557		     1		.data		
 00000557 54 68 65 20 73     1		??001D BYTE "The sum of both matrices is",0ah,0dh,0,0	
	   75 6D 20 6F 66
	   20 62 6F 74 68
	   20 6D 61 74 72
	   69 63 65 73 20
	   69 73 0A 0D 00
	   00
 00000469		     1		.code
 00000469  52		     1		push	edx
 0000046A  BA 00000557 R     1		mov	edx,OFFSET ??001D
 0000046F  E8 00000000 E     1		call	WriteString
 00000474  5A		     1		pop	edx
 00000475  B9 00000006				mov ecx,6
 0000047A  BE 00000000				mov esi,0
 0000047F					L63:
 0000047F  8B 86 00000234 R				mov eax,arr[esi]
 00000485  03 86 00000258 R				add eax,arr1[esi]
							.if ecx==3
 0000048B  83 F9 03	   *	    cmp    ecx, 003h
 0000048E  75 0C	   *	    jne    @C0038
							mwrite<"	",0ah,0dh,0>
 00000576		     1		.data		
 00000576 09 0A 0D 00 00     1		??001E BYTE "	",0ah,0dh,0,0	
 00000490		     1		.code
 00000490  52		     1		push	edx
 00000491  BA 00000576 R     1		mov	edx,OFFSET ??001E
 00000496  E8 00000000 E     1		call	WriteString
 0000049B  5A		     1		pop	edx
							.endif
 0000049C		   *@C0038:
							mwrite<"	",0>
 0000057B		     1		.data		
 0000057B 09 00 00	     1		??001F BYTE "	",0,0	
 0000049C		     1		.code
 0000049C  52		     1		push	edx
 0000049D  BA 0000057B R     1		mov	edx,OFFSET ??001F
 000004A2  E8 00000000 E     1		call	WriteString
 000004A7  5A		     1		pop	edx
 000004A8  E8 00000000 E				call writeint
 000004AD  83 C6 04					add esi,type arr1
 000004B0  E2 CD				loop L63
 000004B2  E9 000001E6				jmp LExit

 000004B7				case7:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 0000057E		     1		.data		
 0000057E 45 6E 74 65 72     1		??0020 BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 000004B7		     1		.code
 000004B7  52		     1		push	edx
 000004B8  BA 0000057E R     1		mov	edx,OFFSET ??0020
 000004BD  E8 00000000 E     1		call	WriteString
 000004C2  5A		     1		pop	edx
 000004C3  BE 00000000				mov esi,0
 000004C8  B9 00000003				mov ecx,3
 000004CD					L71:
 000004CD  E8 00000000 E				call readint
 000004D2  89 86 00000234 R				mov arr[esi],eax
 000004D8  83 C6 04					add esi,type arr
 000004DB  E2 F0				loop L71

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 000005A1		     1		.data		
 000005A1 45 6E 74 65 72     1		??0021 BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 000004DD		     1		.code
 000004DD  52		     1		push	edx
 000004DE  BA 000005A1 R     1		mov	edx,OFFSET ??0021
 000004E3  E8 00000000 E     1		call	WriteString
 000004E8  5A		     1		pop	edx
 000004E9  BE 00000000				mov esi,0
 000004EE  B9 00000003				mov ecx,3
 000004F3					L72:
 000004F3  E8 00000000 E				call readint
 000004F8  89 86 00000258 R				mov arr1[esi],eax
 000004FE  83 C6 04					add esi,type arr1
 00000501  E2 F0				loop L72

						mwrite<"The sum of both matrices is",0ah,0dh,0>
 000005C4		     1		.data		
 000005C4 54 68 65 20 73     1		??0022 BYTE "The sum of both matrices is",0ah,0dh,0,0	
	   75 6D 20 6F 66
	   20 62 6F 74 68
	   20 6D 61 74 72
	   69 63 65 73 20
	   69 73 0A 0D 00
	   00
 00000503		     1		.code
 00000503  52		     1		push	edx
 00000504  BA 000005C4 R     1		mov	edx,OFFSET ??0022
 00000509  E8 00000000 E     1		call	WriteString
 0000050E  5A		     1		pop	edx
 0000050F  B9 00000003				mov ecx,3
 00000514  BE 00000000				mov esi,0
 00000519					L73:
 00000519  8B 86 00000234 R				mov eax,arr[esi]
 0000051F  03 86 00000258 R				add eax,arr1[esi]
							.if ecx==2 || ecx==1
 00000525  83 F9 02	   *	    cmp    ecx, 002h
 00000528  74 05	   *	    je	@C003B
 0000052A  83 F9 01	   *	    cmp    ecx, 001h
 0000052D  75 0C	   *	    jne    @C003A
 0000052F		   *@C003B:
							mwrite<"	",0ah,0dh,0>
 000005E3		     1		.data		
 000005E3 09 0A 0D 00 00     1		??0023 BYTE "	",0ah,0dh,0,0	
 0000052F		     1		.code
 0000052F  52		     1		push	edx
 00000530  BA 000005E3 R     1		mov	edx,OFFSET ??0023
 00000535  E8 00000000 E     1		call	WriteString
 0000053A  5A		     1		pop	edx
							.endif
 0000053B		   *@C003A:
							mwrite<"	",0>
 000005E8		     1		.data		
 000005E8 09 00 00	     1		??0024 BYTE "	",0,0	
 0000053B		     1		.code
 0000053B  52		     1		push	edx
 0000053C  BA 000005E8 R     1		mov	edx,OFFSET ??0024
 00000541  E8 00000000 E     1		call	WriteString
 00000546  5A		     1		pop	edx
 00000547  E8 00000000 E				call writeint
 0000054C  83 C6 04					add esi,type arr1
 0000054F  E2 C8				loop L73
 00000551  E9 00000147				jmp LExit

 00000556				case8:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 000005EB		     1		.data		
 000005EB 45 6E 74 65 72     1		??0025 BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 00000556		     1		.code
 00000556  52		     1		push	edx
 00000557  BA 000005EB R     1		mov	edx,OFFSET ??0025
 0000055C  E8 00000000 E     1		call	WriteString
 00000561  5A		     1		pop	edx
 00000562  BE 00000000				mov esi,0
 00000567  B9 00000006				mov ecx,6
 0000056C					L81:
 0000056C  E8 00000000 E				call readint
 00000571  89 86 00000234 R				mov arr[esi],eax
 00000577  83 C6 04					add esi,type arr
 0000057A  E2 F0				loop L81

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 0000060E		     1		.data		
 0000060E 45 6E 74 65 72     1		??0026 BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 0000057C		     1		.code
 0000057C  52		     1		push	edx
 0000057D  BA 0000060E R     1		mov	edx,OFFSET ??0026
 00000582  E8 00000000 E     1		call	WriteString
 00000587  5A		     1		pop	edx
 00000588  BE 00000000				mov esi,0
 0000058D  B9 00000006				mov ecx,6
 00000592					L82:
 00000592  E8 00000000 E				call readint
 00000597  89 86 00000258 R				mov arr1[esi],eax
 0000059D  83 C6 04					add esi,type arr1
 000005A0  E2 F0				loop L82

						mwrite<"The sum of both matrices is",0ah,0dh,0>
 00000631		     1		.data		
 00000631 54 68 65 20 73     1		??0027 BYTE "The sum of both matrices is",0ah,0dh,0,0	
	   75 6D 20 6F 66
	   20 62 6F 74 68
	   20 6D 61 74 72
	   69 63 65 73 20
	   69 73 0A 0D 00
	   00
 000005A2		     1		.code
 000005A2  52		     1		push	edx
 000005A3  BA 00000631 R     1		mov	edx,OFFSET ??0027
 000005A8  E8 00000000 E     1		call	WriteString
 000005AD  5A		     1		pop	edx
 000005AE  B9 00000006				mov ecx,6
 000005B3  BE 00000000				mov esi,0
 000005B8					L83:
 000005B8  8B 86 00000234 R				mov eax,arr[esi]
 000005BE  03 86 00000258 R				add eax,arr1[esi]
							.if ecx==4 || ecx==2
 000005C4  83 F9 04	   *	    cmp    ecx, 004h
 000005C7  74 05	   *	    je	@C003E
 000005C9  83 F9 02	   *	    cmp    ecx, 002h
 000005CC  75 0C	   *	    jne    @C003D
 000005CE		   *@C003E:
							mwrite<"	",0ah,0dh,0>
 00000650		     1		.data		
 00000650 09 0A 0D 00 00     1		??0028 BYTE "	",0ah,0dh,0,0	
 000005CE		     1		.code
 000005CE  52		     1		push	edx
 000005CF  BA 00000650 R     1		mov	edx,OFFSET ??0028
 000005D4  E8 00000000 E     1		call	WriteString
 000005D9  5A		     1		pop	edx
							.endif
 000005DA		   *@C003D:
							mwrite<"	",0>
 00000655		     1		.data		
 00000655 09 00 00	     1		??0029 BYTE "	",0,0	
 000005DA		     1		.code
 000005DA  52		     1		push	edx
 000005DB  BA 00000655 R     1		mov	edx,OFFSET ??0029
 000005E0  E8 00000000 E     1		call	WriteString
 000005E5  5A		     1		pop	edx
 000005E6  E8 00000000 E				call writeint
 000005EB  83 C6 04					add esi,type arr1
 000005EE  E2 C8				loop L83
 000005F0  E9 000000A8				jmp LExit

 000005F5				case9:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 00000658		     1		.data		
 00000658 45 6E 74 65 72     1		??002A BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 000005F5		     1		.code
 000005F5  52		     1		push	edx
 000005F6  BA 00000658 R     1		mov	edx,OFFSET ??002A
 000005FB  E8 00000000 E     1		call	WriteString
 00000600  5A		     1		pop	edx
 00000601  BE 00000000				mov esi,0
 00000606  B9 00000009				mov ecx,9
 0000060B					L91:
 0000060B  E8 00000000 E				call readint
 00000610  89 86 00000234 R				mov arr[esi],eax
 00000616  83 C6 04					add esi,type arr
 00000619  E2 F0				loop L91

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 0000067B		     1		.data		
 0000067B 45 6E 74 65 72     1		??002B BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 0000061B		     1		.code
 0000061B  52		     1		push	edx
 0000061C  BA 0000067B R     1		mov	edx,OFFSET ??002B
 00000621  E8 00000000 E     1		call	WriteString
 00000626  5A		     1		pop	edx
 00000627  BE 00000000				mov esi,0
 0000062C  B9 00000009				mov ecx,9
 00000631					L92:
 00000631  E8 00000000 E				call readint
 00000636  89 86 00000258 R				mov arr1[esi],eax
 0000063C  83 C6 04					add esi,type arr1
 0000063F  E2 F0				loop L92

						mwrite<"The sum of both matrices is",0ah,0dh,0>
 0000069E		     1		.data		
 0000069E 54 68 65 20 73     1		??002C BYTE "The sum of both matrices is",0ah,0dh,0,0	
	   75 6D 20 6F 66
	   20 62 6F 74 68
	   20 6D 61 74 72
	   69 63 65 73 20
	   69 73 0A 0D 00
	   00
 00000641		     1		.code
 00000641  52		     1		push	edx
 00000642  BA 0000069E R     1		mov	edx,OFFSET ??002C
 00000647  E8 00000000 E     1		call	WriteString
 0000064C  5A		     1		pop	edx
 0000064D  B9 00000009				mov ecx,9
 00000652  BE 00000000				mov esi,0
 00000657					L93:
 00000657  8B 86 00000234 R				mov eax,arr[esi]
 0000065D  03 86 00000258 R				add eax,arr1[esi]
							mwrite<"	",0>
 000006BD		     1		.data		
 000006BD 09 00 00	     1		??002D BYTE "	",0,0	
 00000663		     1		.code
 00000663  52		     1		push	edx
 00000664  BA 000006BD R     1		mov	edx,OFFSET ??002D
 00000669  E8 00000000 E     1		call	WriteString
 0000066E  5A		     1		pop	edx
							.if ecx==6 || ecx==3
 0000066F  83 F9 06	   *	    cmp    ecx, 006h
 00000672  74 05	   *	    je	@C0041
 00000674  83 F9 03	   *	    cmp    ecx, 003h
 00000677  75 18	   *	    jne    @C0040
 00000679		   *@C0041:
								mwrite<0ah,0dh,0>
 000006C0		     1		.data		
 000006C0 0A 0D 00 00	     1		??002E BYTE 0ah,0dh,0,0	
 00000679		     1		.code
 00000679  52		     1		push	edx
 0000067A  BA 000006C0 R     1		mov	edx,OFFSET ??002E
 0000067F  E8 00000000 E     1		call	WriteString
 00000684  5A		     1		pop	edx
								mwrite<"	",0>
 000006C4		     1		.data		
 000006C4 09 00 00	     1		??002F BYTE "	",0,0	
 00000685		     1		.code
 00000685  52		     1		push	edx
 00000686  BA 000006C4 R     1		mov	edx,OFFSET ??002F
 0000068B  E8 00000000 E     1		call	WriteString
 00000690  5A		     1		pop	edx
							.endif
 00000691		   *@C0040:
 00000691  E8 00000000 E				call writeint
 00000696  83 C6 04					add esi,type arr1
 00000699  E2 BC				loop L93
 0000069B  EB 00				jmp LExit
 0000069D				LExit:
 0000069D  C3					ret
 0000069E				sum endp

				;procedure for the subtraction of matrices
 0000069E			Subtraction PROC
 0000069E  E8 00000000 E	call crlf
 000006A3  BA 00000166 R		mov edx,offset selectString
 000006A8  E8 00000000 E		call writestring
 000006AD  E8 00000000 E		call crlf
					mwrite<"Enter your choice << ",0>
 000006C7		     1		.data		
 000006C7 45 6E 74 65 72     1		??0030 BYTE "Enter your choice << ",0,0	
	   20 79 6F 75 72
	   20 63 68 6F 69
	   63 65 20 3C 3C
	   20 00 00
 000006B2		     1		.code
 000006B2  52		     1		push	edx
 000006B3  BA 000006C7 R     1		mov	edx,OFFSET ??0030
 000006B8  E8 00000000 E     1		call	WriteString
 000006BD  5A		     1		pop	edx
 000006BE  E8 00000000 E		call readint 
					mwrite<"----------------------",0ah,0dh>
 000006DE		     1		.data		
 000006DE 2D 2D 2D 2D 2D     1		??0031 BYTE "----------------------",0ah,0dh,0	
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 0A 0D 00
 000006C3		     1		.code
 000006C3  52		     1		push	edx
 000006C4  BA 000006DE R     1		mov	edx,OFFSET ??0031
 000006C9  E8 00000000 E     1		call	WriteString
 000006CE  5A		     1		pop	edx
					.if eax==1
 000006CF  83 F8 01	   *	    cmp    eax, 001h
 000006D2  75 04	   *	    jne    @C0043
 000006D4  EB 60			jmp case1
					.elseif eax==2
 000006D6  EB 5E	   *	    jmp    @C0045
 000006D8		   *@C0043:
 000006D8  83 F8 02	   *	    cmp    eax, 002h
 000006DB  75 07	   *	    jne    @C0046
 000006DD  E9 000000DD			jmp case2
					.elseif  eax==3
 000006E2  EB 52	   *	    jmp    @C0048
 000006E4		   *@C0046:
 000006E4  83 F8 03	   *	    cmp    eax, 003h
 000006E7  75 07	   *	    jne    @C0049
 000006E9  E9 0000015A			jmp case3
					.elseif eax==4
 000006EE  EB 46	   *	    jmp    @C004B
 000006F0		   *@C0049:
 000006F0  83 F8 04	   *	    cmp    eax, 004h
 000006F3  75 07	   *	    jne    @C004C
 000006F5  E9 000001D7			jmp case4
					.elseif eax==5
 000006FA  EB 3A	   *	    jmp    @C004E
 000006FC		   *@C004C:
 000006FC  83 F8 05	   *	    cmp    eax, 005h
 000006FF  75 07	   *	    jne    @C004F
 00000701  E9 00000265			jmp case5
					.elseif eax==6
 00000706  EB 2E	   *	    jmp    @C0051
 00000708		   *@C004F:
 00000708  83 F8 06	   *	    cmp    eax, 006h
 0000070B  75 07	   *	    jne    @C0052
 0000070D  E9 000002F3			jmp case6
					.elseif eax==7
 00000712  EB 22	   *	    jmp    @C0054
 00000714		   *@C0052:
 00000714  83 F8 07	   *	    cmp    eax, 007h
 00000717  75 07	   *	    jne    @C0055
 00000719  E9 00000381			jmp case7
					.elseif eax==8
 0000071E  EB 16	   *	    jmp    @C0057
 00000720		   *@C0055:
 00000720  83 F8 08	   *	    cmp    eax, 008h
 00000723  75 07	   *	    jne    @C0058
 00000725  E9 00000414			jmp case8
					.elseif eax==9
 0000072A  EB 0A	   *	    jmp    @C005A
 0000072C		   *@C0058:
 0000072C  83 F8 09	   *	    cmp    eax, 009h
 0000072F  75 05	   *	    jne    @C005B
 00000731  E9 000004A7			jmp case9
					.endif
 00000736		   *@C005B:
 00000736		   *@C005A:
 00000736		   *@C0057:
 00000736		   *@C0054:
 00000736		   *@C0051:
 00000736		   *@C004E:
 00000736		   *@C004B:
 00000736		   *@C0048:
 00000736		   *@C0045:
 00000736				case1:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 000006F7		     1		.data		
 000006F7 45 6E 74 65 72     1		??0032 BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 00000736		     1		.code
 00000736  52		     1		push	edx
 00000737  BA 000006F7 R     1		mov	edx,OFFSET ??0032
 0000073C  E8 00000000 E     1		call	WriteString
 00000741  5A		     1		pop	edx
 00000742  BE 00000000				mov esi,0
 00000747  B9 00000001				mov ecx,1
 0000074C					L11:
 0000074C  E8 00000000 E				call readint
 00000751  89 86 00000234 R				mov arr[esi],eax
 00000757  83 C6 04					add esi,type arr
 0000075A  E2 F0				loop L11

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 0000071A		     1		.data		
 0000071A 45 6E 74 65 72     1		??0033 BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 0000075C		     1		.code
 0000075C  52		     1		push	edx
 0000075D  BA 0000071A R     1		mov	edx,OFFSET ??0033
 00000762  E8 00000000 E     1		call	WriteString
 00000767  5A		     1		pop	edx
 00000768  BE 00000000				mov esi,0
 0000076D  B9 00000001				mov ecx,1
 00000772					L12:
 00000772  E8 00000000 E				call readint
 00000777  89 86 00000258 R				mov arr1[esi],eax
 0000077D  83 C6 04					add esi,type arr1
 00000780  E2 F0				loop L12

						mwrite<"The Subtraction of both matrices is",0ah,0dh,0>
 0000073D		     1		.data		
 0000073D 54 68 65 20 53     1		??0034 BYTE "The Subtraction of both matrices is",0ah,0dh,0,0	
	   75 62 74 72 61
	   63 74 69 6F 6E
	   20 6F 66 20 62
	   6F 74 68 20 6D
	   61 74 72 69 63
	   65 73 20 69 73
	   0A 0D 00 00
 00000782		     1		.code
 00000782  52		     1		push	edx
 00000783  BA 0000073D R     1		mov	edx,OFFSET ??0034
 00000788  E8 00000000 E     1		call	WriteString
 0000078D  5A		     1		pop	edx
 0000078E  B9 00000001				mov ecx,1
 00000793  BE 00000000				mov esi,0
 00000798					L13:
 00000798  8B 86 00000234 R				mov eax,arr[esi]
 0000079E  2B 86 00000258 R				sub eax,arr1[esi]
							mwrite<"	",0>
 00000764		     1		.data		
 00000764 09 00 00	     1		??0035 BYTE "	",0,0	
 000007A4		     1		.code
 000007A4  52		     1		push	edx
 000007A5  BA 00000764 R     1		mov	edx,OFFSET ??0035
 000007AA  E8 00000000 E     1		call	WriteString
 000007AF  5A		     1		pop	edx
 000007B0  E8 00000000 E				call writeint
 000007B5  83 C6 04					add esi,type arr1
 000007B8  E2 DE				loop L13
 000007BA  E9 000004C6				jmp LExit
 000007BF				case2:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 00000767		     1		.data		
 00000767 45 6E 74 65 72     1		??0036 BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 000007BF		     1		.code
 000007BF  52		     1		push	edx
 000007C0  BA 00000767 R     1		mov	edx,OFFSET ??0036
 000007C5  E8 00000000 E     1		call	WriteString
 000007CA  5A		     1		pop	edx
 000007CB  BE 00000000				mov esi,0
 000007D0  B9 00000002				mov ecx,2
 000007D5					L21:
 000007D5  E8 00000000 E				call readint
 000007DA  89 86 00000234 R				mov arr[esi],eax
 000007E0  83 C6 04					add esi,type arr
 000007E3  E2 F0				loop L21

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 0000078A		     1		.data		
 0000078A 45 6E 74 65 72     1		??0037 BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 000007E5		     1		.code
 000007E5  52		     1		push	edx
 000007E6  BA 0000078A R     1		mov	edx,OFFSET ??0037
 000007EB  E8 00000000 E     1		call	WriteString
 000007F0  5A		     1		pop	edx
 000007F1  BE 00000000				mov esi,0
 000007F6  B9 00000002				mov ecx,2
 000007FB					L22:
 000007FB  E8 00000000 E				call readint
 00000800  89 86 00000258 R				mov arr1[esi],eax
 00000806  83 C6 04					add esi,type arr1
 00000809  E2 F0				loop L22

						mwrite<"The Subtraction of both matrices is",0ah,0dh,0>
 000007AD		     1		.data		
 000007AD 54 68 65 20 53     1		??0038 BYTE "The Subtraction of both matrices is",0ah,0dh,0,0	
	   75 62 74 72 61
	   63 74 69 6F 6E
	   20 6F 66 20 62
	   6F 74 68 20 6D
	   61 74 72 69 63
	   65 73 20 69 73
	   0A 0D 00 00
 0000080B		     1		.code
 0000080B  52		     1		push	edx
 0000080C  BA 000007AD R     1		mov	edx,OFFSET ??0038
 00000811  E8 00000000 E     1		call	WriteString
 00000816  5A		     1		pop	edx
 00000817  B9 00000002				mov ecx,2
 0000081C  BE 00000000				mov esi,0
 00000821					L23:
 00000821  8B 86 00000234 R				mov eax,arr[esi]
 00000827  2B 86 00000258 R				sub eax,arr1[esi]
							mwrite<"	",0>
 000007D4		     1		.data		
 000007D4 09 00 00	     1		??0039 BYTE "	",0,0	
 0000082D		     1		.code
 0000082D  52		     1		push	edx
 0000082E  BA 000007D4 R     1		mov	edx,OFFSET ??0039
 00000833  E8 00000000 E     1		call	WriteString
 00000838  5A		     1		pop	edx
 00000839  E8 00000000 E				call writeint
 0000083E  83 C6 04					add esi,type arr1
 00000841  E2 DE				loop L23
 00000843  E9 0000043D				jmp LExit
 00000848				case3:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 000007D7		     1		.data		
 000007D7 45 6E 74 65 72     1		??003A BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 00000848		     1		.code
 00000848  52		     1		push	edx
 00000849  BA 000007D7 R     1		mov	edx,OFFSET ??003A
 0000084E  E8 00000000 E     1		call	WriteString
 00000853  5A		     1		pop	edx
 00000854  BE 00000000				mov esi,0
 00000859  B9 00000003				mov ecx,3
 0000085E					L31:
 0000085E  E8 00000000 E				call readint
 00000863  89 86 00000234 R				mov arr[esi],eax
 00000869  83 C6 04					add esi,type arr
 0000086C  E2 F0				loop L31

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 000007FA		     1		.data		
 000007FA 45 6E 74 65 72     1		??003B BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 0000086E		     1		.code
 0000086E  52		     1		push	edx
 0000086F  BA 000007FA R     1		mov	edx,OFFSET ??003B
 00000874  E8 00000000 E     1		call	WriteString
 00000879  5A		     1		pop	edx
 0000087A  BE 00000000				mov esi,0
 0000087F  B9 00000003				mov ecx,3
 00000884					L32:
 00000884  E8 00000000 E				call readint
 00000889  89 86 00000258 R				mov arr1[esi],eax
 0000088F  83 C6 04					add esi,type arr1
 00000892  E2 F0				loop L32

						mwrite<"The Subtraction of both matrices is",0ah,0dh,0>
 0000081D		     1		.data		
 0000081D 54 68 65 20 53     1		??003C BYTE "The Subtraction of both matrices is",0ah,0dh,0,0	
	   75 62 74 72 61
	   63 74 69 6F 6E
	   20 6F 66 20 62
	   6F 74 68 20 6D
	   61 74 72 69 63
	   65 73 20 69 73
	   0A 0D 00 00
 00000894		     1		.code
 00000894  52		     1		push	edx
 00000895  BA 0000081D R     1		mov	edx,OFFSET ??003C
 0000089A  E8 00000000 E     1		call	WriteString
 0000089F  5A		     1		pop	edx
 000008A0  B9 00000003				mov ecx,3
 000008A5  BE 00000000				mov esi,0
 000008AA					L33:
 000008AA  8B 86 00000234 R				mov eax,arr[esi]
 000008B0  2B 86 00000258 R				sub eax,arr1[esi]
							mwrite<"	",0>
 00000844		     1		.data		
 00000844 09 00 00	     1		??003D BYTE "	",0,0	
 000008B6		     1		.code
 000008B6  52		     1		push	edx
 000008B7  BA 00000844 R     1		mov	edx,OFFSET ??003D
 000008BC  E8 00000000 E     1		call	WriteString
 000008C1  5A		     1		pop	edx
 000008C2  E8 00000000 E				call writeint
 000008C7  83 C6 04					add esi,type arr1
 000008CA  E2 DE				loop L33
 000008CC  E9 000003B4				jmp LExit

 000008D1				case4:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 00000847		     1		.data		
 00000847 45 6E 74 65 72     1		??003E BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 000008D1		     1		.code
 000008D1  52		     1		push	edx
 000008D2  BA 00000847 R     1		mov	edx,OFFSET ??003E
 000008D7  E8 00000000 E     1		call	WriteString
 000008DC  5A		     1		pop	edx
 000008DD  BE 00000000				mov esi,0
 000008E2  B9 00000002				mov ecx,2
 000008E7					L41:
 000008E7  E8 00000000 E				call readint
 000008EC  89 86 00000234 R				mov arr[esi],eax
 000008F2  83 C6 04					add esi,type arr
 000008F5  E2 F0				loop L41

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 0000086A		     1		.data		
 0000086A 45 6E 74 65 72     1		??003F BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 000008F7		     1		.code
 000008F7  52		     1		push	edx
 000008F8  BA 0000086A R     1		mov	edx,OFFSET ??003F
 000008FD  E8 00000000 E     1		call	WriteString
 00000902  5A		     1		pop	edx
 00000903  BE 00000000				mov esi,0
 00000908  B9 00000002				mov ecx,2
 0000090D					L42:
 0000090D  E8 00000000 E				call readint
 00000912  89 86 00000258 R				mov arr1[esi],eax
 00000918  83 C6 04					add esi,type arr1
 0000091B  E2 F0				loop L42

						mwrite<"The Subtraction of both matrices is",0ah,0dh,0>
 0000088D		     1		.data		
 0000088D 54 68 65 20 53     1		??0040 BYTE "The Subtraction of both matrices is",0ah,0dh,0,0	
	   75 62 74 72 61
	   63 74 69 6F 6E
	   20 6F 66 20 62
	   6F 74 68 20 6D
	   61 74 72 69 63
	   65 73 20 69 73
	   0A 0D 00 00
 0000091D		     1		.code
 0000091D  52		     1		push	edx
 0000091E  BA 0000088D R     1		mov	edx,OFFSET ??0040
 00000923  E8 00000000 E     1		call	WriteString
 00000928  5A		     1		pop	edx
 00000929  B9 00000002				mov ecx,2
 0000092E  BE 00000000				mov esi,0
 00000933					L43:
 00000933  8B 86 00000234 R				mov eax,arr[esi]
 00000939  2B 86 00000258 R				sub eax,arr1[esi]
							.if ecx==1
 0000093F  83 F9 01	   *	    cmp    ecx, 001h
 00000942  75 0C	   *	    jne    @C005D
							mwrite<"	",0ah,0dh,0>
 000008B4		     1		.data		
 000008B4 09 0A 0D 00 00     1		??0041 BYTE "	",0ah,0dh,0,0	
 00000944		     1		.code
 00000944  52		     1		push	edx
 00000945  BA 000008B4 R     1		mov	edx,OFFSET ??0041
 0000094A  E8 00000000 E     1		call	WriteString
 0000094F  5A		     1		pop	edx
							.endif
 00000950		   *@C005D:
							mwrite<"	",0>
 000008B9		     1		.data		
 000008B9 09 00 00	     1		??0042 BYTE "	",0,0	
 00000950		     1		.code
 00000950  52		     1		push	edx
 00000951  BA 000008B9 R     1		mov	edx,OFFSET ??0042
 00000956  E8 00000000 E     1		call	WriteString
 0000095B  5A		     1		pop	edx
 0000095C  E8 00000000 E				call writeint
 00000961  83 C6 04					add esi,type arr1
 00000964  E2 CD				loop L43
 00000966  E9 0000031A				jmp LExit
 0000096B				case5:
					mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 000008BC		     1		.data		
 000008BC 45 6E 74 65 72     1		??0043 BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 0000096B		     1		.code
 0000096B  52		     1		push	edx
 0000096C  BA 000008BC R     1		mov	edx,OFFSET ??0043
 00000971  E8 00000000 E     1		call	WriteString
 00000976  5A		     1		pop	edx
 00000977  BE 00000000				mov esi,0
 0000097C  B9 00000004				mov ecx,4
 00000981					L51:
 00000981  E8 00000000 E				call readint
 00000986  89 86 00000234 R				mov arr[esi],eax
 0000098C  83 C6 04					add esi,type arr
 0000098F  E2 F0				loop L51

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 000008DF		     1		.data		
 000008DF 45 6E 74 65 72     1		??0044 BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 00000991		     1		.code
 00000991  52		     1		push	edx
 00000992  BA 000008DF R     1		mov	edx,OFFSET ??0044
 00000997  E8 00000000 E     1		call	WriteString
 0000099C  5A		     1		pop	edx
 0000099D  BE 00000000				mov esi,0
 000009A2  B9 00000004				mov ecx,4
 000009A7					L52:
 000009A7  E8 00000000 E				call readint
 000009AC  89 86 00000258 R				mov arr1[esi],eax
 000009B2  83 C6 04					add esi,type arr1
 000009B5  E2 F0				loop L52

						mwrite<"The Subtraction of both matrices is",0ah,0dh,0>
 00000902		     1		.data		
 00000902 54 68 65 20 53     1		??0045 BYTE "The Subtraction of both matrices is",0ah,0dh,0,0	
	   75 62 74 72 61
	   63 74 69 6F 6E
	   20 6F 66 20 62
	   6F 74 68 20 6D
	   61 74 72 69 63
	   65 73 20 69 73
	   0A 0D 00 00
 000009B7		     1		.code
 000009B7  52		     1		push	edx
 000009B8  BA 00000902 R     1		mov	edx,OFFSET ??0045
 000009BD  E8 00000000 E     1		call	WriteString
 000009C2  5A		     1		pop	edx
 000009C3  B9 00000004				mov ecx,4
 000009C8  BE 00000000				mov esi,0
 000009CD					L53:
 000009CD  8B 86 00000234 R				mov eax,arr[esi]
 000009D3  2B 86 00000258 R				sub eax,arr1[esi]
							.if ecx==2
 000009D9  83 F9 02	   *	    cmp    ecx, 002h
 000009DC  75 0C	   *	    jne    @C005F
							mwrite<"	",0ah,0dh,0>
 00000929		     1		.data		
 00000929 09 0A 0D 00 00     1		??0046 BYTE "	",0ah,0dh,0,0	
 000009DE		     1		.code
 000009DE  52		     1		push	edx
 000009DF  BA 00000929 R     1		mov	edx,OFFSET ??0046
 000009E4  E8 00000000 E     1		call	WriteString
 000009E9  5A		     1		pop	edx
							.endif
 000009EA		   *@C005F:
							mwrite<"	",0>
 0000092E		     1		.data		
 0000092E 09 00 00	     1		??0047 BYTE "	",0,0	
 000009EA		     1		.code
 000009EA  52		     1		push	edx
 000009EB  BA 0000092E R     1		mov	edx,OFFSET ??0047
 000009F0  E8 00000000 E     1		call	WriteString
 000009F5  5A		     1		pop	edx
 000009F6  E8 00000000 E				call writeint
 000009FB  83 C6 04					add esi,type arr1
 000009FE  E2 CD				loop L53
 00000A00  E9 00000280				jmp LExit

 00000A05				case6:
					mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 00000931		     1		.data		
 00000931 45 6E 74 65 72     1		??0048 BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 00000A05		     1		.code
 00000A05  52		     1		push	edx
 00000A06  BA 00000931 R     1		mov	edx,OFFSET ??0048
 00000A0B  E8 00000000 E     1		call	WriteString
 00000A10  5A		     1		pop	edx
 00000A11  BE 00000000				mov esi,0
 00000A16  B9 00000006				mov ecx,6
 00000A1B					L61:
 00000A1B  E8 00000000 E				call readint
 00000A20  89 86 00000234 R				mov arr[esi],eax
 00000A26  83 C6 04					add esi,type arr
 00000A29  E2 F0				loop L61

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 00000954		     1		.data		
 00000954 45 6E 74 65 72     1		??0049 BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 00000A2B		     1		.code
 00000A2B  52		     1		push	edx
 00000A2C  BA 00000954 R     1		mov	edx,OFFSET ??0049
 00000A31  E8 00000000 E     1		call	WriteString
 00000A36  5A		     1		pop	edx
 00000A37  BE 00000000				mov esi,0
 00000A3C  B9 00000006				mov ecx,6
 00000A41					L62:
 00000A41  E8 00000000 E				call readint
 00000A46  89 86 00000258 R				mov arr1[esi],eax
 00000A4C  83 C6 04					add esi,type arr1
 00000A4F  E2 F0				loop L62

						mwrite<"The Subtraction of both matrices is",0ah,0dh,0>
 00000977		     1		.data		
 00000977 54 68 65 20 53     1		??004A BYTE "The Subtraction of both matrices is",0ah,0dh,0,0	
	   75 62 74 72 61
	   63 74 69 6F 6E
	   20 6F 66 20 62
	   6F 74 68 20 6D
	   61 74 72 69 63
	   65 73 20 69 73
	   0A 0D 00 00
 00000A51		     1		.code
 00000A51  52		     1		push	edx
 00000A52  BA 00000977 R     1		mov	edx,OFFSET ??004A
 00000A57  E8 00000000 E     1		call	WriteString
 00000A5C  5A		     1		pop	edx
 00000A5D  B9 00000006				mov ecx,6
 00000A62  BE 00000000				mov esi,0
 00000A67					L63:
 00000A67  8B 86 00000234 R				mov eax,arr[esi]
 00000A6D  2B 86 00000258 R				sub eax,arr1[esi]
							.if ecx==3
 00000A73  83 F9 03	   *	    cmp    ecx, 003h
 00000A76  75 0C	   *	    jne    @C0061
							mwrite<"	",0ah,0dh,0>
 0000099E		     1		.data		
 0000099E 09 0A 0D 00 00     1		??004B BYTE "	",0ah,0dh,0,0	
 00000A78		     1		.code
 00000A78  52		     1		push	edx
 00000A79  BA 0000099E R     1		mov	edx,OFFSET ??004B
 00000A7E  E8 00000000 E     1		call	WriteString
 00000A83  5A		     1		pop	edx
							.endif
 00000A84		   *@C0061:
							mwrite<"	",0>
 000009A3		     1		.data		
 000009A3 09 00 00	     1		??004C BYTE "	",0,0	
 00000A84		     1		.code
 00000A84  52		     1		push	edx
 00000A85  BA 000009A3 R     1		mov	edx,OFFSET ??004C
 00000A8A  E8 00000000 E     1		call	WriteString
 00000A8F  5A		     1		pop	edx
 00000A90  E8 00000000 E				call writeint
 00000A95  83 C6 04					add esi,type arr1
 00000A98  E2 CD				loop L63
 00000A9A  E9 000001E6				jmp LExit

 00000A9F				case7:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 000009A6		     1		.data		
 000009A6 45 6E 74 65 72     1		??004D BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 00000A9F		     1		.code
 00000A9F  52		     1		push	edx
 00000AA0  BA 000009A6 R     1		mov	edx,OFFSET ??004D
 00000AA5  E8 00000000 E     1		call	WriteString
 00000AAA  5A		     1		pop	edx
 00000AAB  BE 00000000				mov esi,0
 00000AB0  B9 00000003				mov ecx,3
 00000AB5					L71:
 00000AB5  E8 00000000 E				call readint
 00000ABA  89 86 00000234 R				mov arr[esi],eax
 00000AC0  83 C6 04					add esi,type arr
 00000AC3  E2 F0				loop L71

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 000009C9		     1		.data		
 000009C9 45 6E 74 65 72     1		??004E BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 00000AC5		     1		.code
 00000AC5  52		     1		push	edx
 00000AC6  BA 000009C9 R     1		mov	edx,OFFSET ??004E
 00000ACB  E8 00000000 E     1		call	WriteString
 00000AD0  5A		     1		pop	edx
 00000AD1  BE 00000000				mov esi,0
 00000AD6  B9 00000003				mov ecx,3
 00000ADB					L72:
 00000ADB  E8 00000000 E				call readint
 00000AE0  89 86 00000258 R				mov arr1[esi],eax
 00000AE6  83 C6 04					add esi,type arr1
 00000AE9  E2 F0				loop L72

						mwrite<"The Subtraction of both matrices is",0ah,0dh,0>
 000009EC		     1		.data		
 000009EC 54 68 65 20 53     1		??004F BYTE "The Subtraction of both matrices is",0ah,0dh,0,0	
	   75 62 74 72 61
	   63 74 69 6F 6E
	   20 6F 66 20 62
	   6F 74 68 20 6D
	   61 74 72 69 63
	   65 73 20 69 73
	   0A 0D 00 00
 00000AEB		     1		.code
 00000AEB  52		     1		push	edx
 00000AEC  BA 000009EC R     1		mov	edx,OFFSET ??004F
 00000AF1  E8 00000000 E     1		call	WriteString
 00000AF6  5A		     1		pop	edx
 00000AF7  B9 00000003				mov ecx,3
 00000AFC  BE 00000000				mov esi,0
 00000B01					L73:
 00000B01  8B 86 00000234 R				mov eax,arr[esi]
 00000B07  2B 86 00000258 R				sub eax,arr1[esi]
							.if ecx==2 || ecx==1
 00000B0D  83 F9 02	   *	    cmp    ecx, 002h
 00000B10  74 05	   *	    je	@C0064
 00000B12  83 F9 01	   *	    cmp    ecx, 001h
 00000B15  75 0C	   *	    jne    @C0063
 00000B17		   *@C0064:
							mwrite<"	",0ah,0dh,0>
 00000A13		     1		.data		
 00000A13 09 0A 0D 00 00     1		??0050 BYTE "	",0ah,0dh,0,0	
 00000B17		     1		.code
 00000B17  52		     1		push	edx
 00000B18  BA 00000A13 R     1		mov	edx,OFFSET ??0050
 00000B1D  E8 00000000 E     1		call	WriteString
 00000B22  5A		     1		pop	edx
							.endif
 00000B23		   *@C0063:
							mwrite<"	",0>
 00000A18		     1		.data		
 00000A18 09 00 00	     1		??0051 BYTE "	",0,0	
 00000B23		     1		.code
 00000B23  52		     1		push	edx
 00000B24  BA 00000A18 R     1		mov	edx,OFFSET ??0051
 00000B29  E8 00000000 E     1		call	WriteString
 00000B2E  5A		     1		pop	edx
 00000B2F  E8 00000000 E				call writeint
 00000B34  83 C6 04					add esi,type arr1
 00000B37  E2 C8				loop L73
 00000B39  E9 00000147				jmp LExit

 00000B3E				case8:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 00000A1B		     1		.data		
 00000A1B 45 6E 74 65 72     1		??0052 BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 00000B3E		     1		.code
 00000B3E  52		     1		push	edx
 00000B3F  BA 00000A1B R     1		mov	edx,OFFSET ??0052
 00000B44  E8 00000000 E     1		call	WriteString
 00000B49  5A		     1		pop	edx
 00000B4A  BE 00000000				mov esi,0
 00000B4F  B9 00000006				mov ecx,6
 00000B54					L81:
 00000B54  E8 00000000 E				call readint
 00000B59  89 86 00000234 R				mov arr[esi],eax
 00000B5F  83 C6 04					add esi,type arr
 00000B62  E2 F0				loop L81

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 00000A3E		     1		.data		
 00000A3E 45 6E 74 65 72     1		??0053 BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 00000B64		     1		.code
 00000B64  52		     1		push	edx
 00000B65  BA 00000A3E R     1		mov	edx,OFFSET ??0053
 00000B6A  E8 00000000 E     1		call	WriteString
 00000B6F  5A		     1		pop	edx
 00000B70  BE 00000000				mov esi,0
 00000B75  B9 00000006				mov ecx,6
 00000B7A					L82:
 00000B7A  E8 00000000 E				call readint
 00000B7F  89 86 00000258 R				mov arr1[esi],eax
 00000B85  83 C6 04					add esi,type arr1
 00000B88  E2 F0				loop L82

						mwrite<"The Subtraction of both matrices is",0ah,0dh,0>
 00000A61		     1		.data		
 00000A61 54 68 65 20 53     1		??0054 BYTE "The Subtraction of both matrices is",0ah,0dh,0,0	
	   75 62 74 72 61
	   63 74 69 6F 6E
	   20 6F 66 20 62
	   6F 74 68 20 6D
	   61 74 72 69 63
	   65 73 20 69 73
	   0A 0D 00 00
 00000B8A		     1		.code
 00000B8A  52		     1		push	edx
 00000B8B  BA 00000A61 R     1		mov	edx,OFFSET ??0054
 00000B90  E8 00000000 E     1		call	WriteString
 00000B95  5A		     1		pop	edx
 00000B96  B9 00000006				mov ecx,6
 00000B9B  BE 00000000				mov esi,0
 00000BA0					L83:
 00000BA0  8B 86 00000234 R				mov eax,arr[esi]
 00000BA6  2B 86 00000258 R				sub eax,arr1[esi]
							.if ecx==4 || ecx==2
 00000BAC  83 F9 04	   *	    cmp    ecx, 004h
 00000BAF  74 05	   *	    je	@C0067
 00000BB1  83 F9 02	   *	    cmp    ecx, 002h
 00000BB4  75 0C	   *	    jne    @C0066
 00000BB6		   *@C0067:
							mwrite<"	",0ah,0dh,0>
 00000A88		     1		.data		
 00000A88 09 0A 0D 00 00     1		??0055 BYTE "	",0ah,0dh,0,0	
 00000BB6		     1		.code
 00000BB6  52		     1		push	edx
 00000BB7  BA 00000A88 R     1		mov	edx,OFFSET ??0055
 00000BBC  E8 00000000 E     1		call	WriteString
 00000BC1  5A		     1		pop	edx
							.endif
 00000BC2		   *@C0066:
							mwrite<"	",0>
 00000A8D		     1		.data		
 00000A8D 09 00 00	     1		??0056 BYTE "	",0,0	
 00000BC2		     1		.code
 00000BC2  52		     1		push	edx
 00000BC3  BA 00000A8D R     1		mov	edx,OFFSET ??0056
 00000BC8  E8 00000000 E     1		call	WriteString
 00000BCD  5A		     1		pop	edx
 00000BCE  E8 00000000 E				call writeint
 00000BD3  83 C6 04					add esi,type arr1
 00000BD6  E2 C8				loop L83
 00000BD8  E9 000000A8				jmp LExit

 00000BDD				case9:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 00000A90		     1		.data		
 00000A90 45 6E 74 65 72     1		??0057 BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 00000BDD		     1		.code
 00000BDD  52		     1		push	edx
 00000BDE  BA 00000A90 R     1		mov	edx,OFFSET ??0057
 00000BE3  E8 00000000 E     1		call	WriteString
 00000BE8  5A		     1		pop	edx
 00000BE9  BE 00000000				mov esi,0
 00000BEE  B9 00000009				mov ecx,9
 00000BF3					L91:
 00000BF3  E8 00000000 E				call readint
 00000BF8  89 86 00000234 R				mov arr[esi],eax
 00000BFE  83 C6 04					add esi,type arr
 00000C01  E2 F0				loop L91

						mwrite<"Enter the elements of Matrix 02",0ah,0dh,0>
 00000AB3		     1		.data		
 00000AB3 45 6E 74 65 72     1		??0058 BYTE "Enter the elements of Matrix 02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   32 0A 0D 00 00
 00000C03		     1		.code
 00000C03  52		     1		push	edx
 00000C04  BA 00000AB3 R     1		mov	edx,OFFSET ??0058
 00000C09  E8 00000000 E     1		call	WriteString
 00000C0E  5A		     1		pop	edx
 00000C0F  BE 00000000				mov esi,0
 00000C14  B9 00000009				mov ecx,9
 00000C19					L92:
 00000C19  E8 00000000 E				call readint
 00000C1E  89 86 00000258 R				mov arr1[esi],eax
 00000C24  83 C6 04					add esi,type arr1
 00000C27  E2 F0				loop L92

						mwrite<"The Subtraction of both matrices is",0ah,0dh,0>
 00000AD6		     1		.data		
 00000AD6 54 68 65 20 53     1		??0059 BYTE "The Subtraction of both matrices is",0ah,0dh,0,0	
	   75 62 74 72 61
	   63 74 69 6F 6E
	   20 6F 66 20 62
	   6F 74 68 20 6D
	   61 74 72 69 63
	   65 73 20 69 73
	   0A 0D 00 00
 00000C29		     1		.code
 00000C29  52		     1		push	edx
 00000C2A  BA 00000AD6 R     1		mov	edx,OFFSET ??0059
 00000C2F  E8 00000000 E     1		call	WriteString
 00000C34  5A		     1		pop	edx
 00000C35  B9 00000009				mov ecx,9
 00000C3A  BE 00000000				mov esi,0
 00000C3F					L93:
 00000C3F  8B 86 00000234 R				mov eax,arr[esi]
 00000C45  2B 86 00000258 R				sub eax,arr1[esi]
							mwrite<"	",0>
 00000AFD		     1		.data		
 00000AFD 09 00 00	     1		??005A BYTE "	",0,0	
 00000C4B		     1		.code
 00000C4B  52		     1		push	edx
 00000C4C  BA 00000AFD R     1		mov	edx,OFFSET ??005A
 00000C51  E8 00000000 E     1		call	WriteString
 00000C56  5A		     1		pop	edx
							.if ecx==6 || ecx==3
 00000C57  83 F9 06	   *	    cmp    ecx, 006h
 00000C5A  74 05	   *	    je	@C006A
 00000C5C  83 F9 03	   *	    cmp    ecx, 003h
 00000C5F  75 18	   *	    jne    @C0069
 00000C61		   *@C006A:
								mwrite<0ah,0dh,0>
 00000B00		     1		.data		
 00000B00 0A 0D 00 00	     1		??005B BYTE 0ah,0dh,0,0	
 00000C61		     1		.code
 00000C61  52		     1		push	edx
 00000C62  BA 00000B00 R     1		mov	edx,OFFSET ??005B
 00000C67  E8 00000000 E     1		call	WriteString
 00000C6C  5A		     1		pop	edx
								mwrite<"	",0>
 00000B04		     1		.data		
 00000B04 09 00 00	     1		??005C BYTE "	",0,0	
 00000C6D		     1		.code
 00000C6D  52		     1		push	edx
 00000C6E  BA 00000B04 R     1		mov	edx,OFFSET ??005C
 00000C73  E8 00000000 E     1		call	WriteString
 00000C78  5A		     1		pop	edx
							.endif
 00000C79		   *@C0069:
 00000C79  E8 00000000 E				call writeint
 00000C7E  83 C6 04					add esi,type arr1
 00000C81  E2 BC				loop L93
 00000C83  EB 00				jmp LExit
 00000C85				LExit:
 00000C85  C3					ret
 00000C86			Subtraction endp

				;procedure for the Adjoint of a given matrix
 00000C86			AdjOf proc
 00000C86  E8 00000000 E	call crlf
					mwrite<"		1.For 2X2 Matrix ",0ah,0dh,0>
 00000B07		     1		.data		
 00000B07 09 09 31 2E 46     1		??005D BYTE "		1.For 2X2 Matrix ",0ah,0dh,0,0	
	   6F 72 20 32 58
	   32 20 4D 61 74
	   72 69 78 20 0A
	   0D 00 00
 00000C8B		     1		.code
 00000C8B  52		     1		push	edx
 00000C8C  BA 00000B07 R     1		mov	edx,OFFSET ??005D
 00000C91  E8 00000000 E     1		call	WriteString
 00000C96  5A		     1		pop	edx
					mwrite<"		2.For 3X3 Matrix ",0ah,0dh,0>
 00000B1E		     1		.data		
 00000B1E 09 09 32 2E 46     1		??005E BYTE "		2.For 3X3 Matrix ",0ah,0dh,0,0	
	   6F 72 20 33 58
	   33 20 4D 61 74
	   72 69 78 20 0A
	   0D 00 00
 00000C97		     1		.code
 00000C97  52		     1		push	edx
 00000C98  BA 00000B1E R     1		mov	edx,OFFSET ??005E
 00000C9D  E8 00000000 E     1		call	WriteString
 00000CA2  5A		     1		pop	edx
					mwrite<"		Enter your Choice: ",0ah,0dh,0>
 00000B35		     1		.data		
 00000B35 09 09 45 6E 74     1		??005F BYTE "		Enter your Choice: ",0ah,0dh,0,0	
	   65 72 20 79 6F
	   75 72 20 43 68
	   6F 69 63 65 3A
	   20 0A 0D 00 00
 00000CA3		     1		.code
 00000CA3  52		     1		push	edx
 00000CA4  BA 00000B35 R     1		mov	edx,OFFSET ??005F
 00000CA9  E8 00000000 E     1		call	WriteString
 00000CAE  5A		     1		pop	edx
					mwrite<"---------------------------------------: ",0>
 00000B4E		     1		.data		
 00000B4E 2D 2D 2D 2D 2D     1		??0060 BYTE "---------------------------------------: ",0,0	
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 3A
	   20 00 00
 00000CAF		     1		.code
 00000CAF  52		     1		push	edx
 00000CB0  BA 00000B4E R     1		mov	edx,OFFSET ??0060
 00000CB5  E8 00000000 E     1		call	WriteString
 00000CBA  5A		     1		pop	edx
 00000CBB  E8 00000000 E		call readint
					.if eax==1
 00000CC0  83 F8 01	   *	    cmp    eax, 001h
 00000CC3  75 04	   *	    jne    @C006C
 00000CC5  EB 07				jmp case1
					.else
 00000CC7  EB 05	   *	    jmp    @C006E
 00000CC9		   *@C006C:
 00000CC9  E9 00000090				jmp case2
					.endif
 00000CCE		   *@C006E:
 00000CCE				case1:
					mwrite<"Enter the elements of Matrix",0ah,0dh,0>
 00000B79		     1		.data		
 00000B79 45 6E 74 65 72     1		??0061 BYTE "Enter the elements of Matrix",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 0A 0D
	   00 00
 00000CCE		     1		.code
 00000CCE  52		     1		push	edx
 00000CCF  BA 00000B79 R     1		mov	edx,OFFSET ??0061
 00000CD4  E8 00000000 E     1		call	WriteString
 00000CD9  5A		     1		pop	edx
 00000CDA  BE 00000000				mov esi,0
 00000CDF  B9 00000004				mov ecx,4
 00000CE4					L11:
 00000CE4  E8 00000000 E				call readint
 00000CE9  89 86 00000234 R				mov arr[esi],eax
 00000CEF  83 C6 04					add esi,type arr
 00000CF2  E2 F0				loop L11

						
 00000CF4  BE 00000000				mov esi,0
 00000CF9  8B 86 00000234 R			mov eax,arr[esi]
 00000CFF  87 86 00000240 R			xchg eax,arr[esi+12]
 00000D05  89 86 00000234 R			mov arr[esi],eax

 00000D0B  8B 86 00000238 R			mov eax,arr[esi+4]
 00000D11  F7 D8				neg eax
 00000D13  89 86 00000238 R			mov arr[esi+4],eax

 00000D19  8B 86 0000023C R			mov eax,arr[esi+8]
 00000D1F  F7 D8				neg eax
 00000D21  89 86 0000023C R			mov arr[esi+8],eax

						;mov esi,0
 00000D27  B9 00000004				mov ecx,4
 00000D2C					L12:
 00000D2C  8B 86 00000234 R				mov eax,arr[esi]
							.if ecx==2
 00000D32  83 F9 02	   *	    cmp    ecx, 002h
 00000D35  75 0C	   *	    jne    @C006F
							mwrite<" ",0ah,0dh,0>
 00000B99		     1		.data		
 00000B99 20 0A 0D 00 00     1		??0062 BYTE " ",0ah,0dh,0,0	
 00000D37		     1		.code
 00000D37  52		     1		push	edx
 00000D38  BA 00000B99 R     1		mov	edx,OFFSET ??0062
 00000D3D  E8 00000000 E     1		call	WriteString
 00000D42  5A		     1		pop	edx
							.endif
 00000D43		   *@C006F:
							mwrite<"	",0>
 00000B9E		     1		.data		
 00000B9E 09 00 00	     1		??0063 BYTE "	",0,0	
 00000D43		     1		.code
 00000D43  52		     1		push	edx
 00000D44  BA 00000B9E R     1		mov	edx,OFFSET ??0063
 00000D49  E8 00000000 E     1		call	WriteString
 00000D4E  5A		     1		pop	edx
 00000D4F  E8 00000000 E				call writeint
 00000D54  83 C6 04					add esi, type arr
 00000D57  E2 D3				loop L12
						
 00000D59  E9 0000028E				jmp LExit
 00000D5E				case2:

					mwrite<"Enter the elements of Matrix",0ah,0dh,0>
 00000BA1		     1		.data		
 00000BA1 45 6E 74 65 72     1		??0064 BYTE "Enter the elements of Matrix",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 0A 0D
	   00 00
 00000D5E		     1		.code
 00000D5E  52		     1		push	edx
 00000D5F  BA 00000BA1 R     1		mov	edx,OFFSET ??0064
 00000D64  E8 00000000 E     1		call	WriteString
 00000D69  5A		     1		pop	edx
 00000D6A  BE 00000000				mov esi,0
 00000D6F  B9 00000009				mov ecx,9
 00000D74					L21:
 00000D74  E8 00000000 E				call readint
 00000D79  89 86 00000234 R				mov arr[esi],eax
 00000D7F  83 C6 04					add esi,type arr
 00000D82  E2 F0				loop L21

						;calculating 1st Cofector
 00000D84  BE 00000000				mov esi,0
 00000D89  8B 86 00000244 R			mov eax,arr[esi+16]
 00000D8F  8B 9E 00000254 R			mov ebx,arr[esi+32]
 00000D95  F7 E3				mul ebx
 00000D97  A3 00000000 R			mov var1,eax
 00000D9C  8B 86 00000248 R			mov eax,arr[esi+20]
 00000DA2  8B 9E 00000250 R			mov ebx,arr[esi+28]
 00000DA8  F7 E3				mul ebx
 00000DAA  A3 00000004 R			mov var2,eax
 00000DAF  A1 00000000 R			mov eax,var1
 00000DB4  2B 05 00000004 R			sub eax,var2
 00000DBA  50					push eax

						;calculating 2nd Cofector
 00000DBB  8B 86 00000240 R			mov eax,arr[esi+12]
 00000DC1  8B 9E 00000254 R			mov ebx,arr[esi+32]
 00000DC7  F7 E3				mul ebx
 00000DC9  A3 00000000 R			mov var1,eax
 00000DCE  8B 86 00000248 R			mov eax,arr[esi+20]
 00000DD4  8B 9E 0000024C R			mov ebx,arr[esi+24]
 00000DDA  F7 E3				mul ebx
 00000DDC  A3 00000004 R			mov var2,eax
 00000DE1  A1 00000000 R			mov eax,var1
 00000DE6  2B 05 00000004 R			sub eax,var2
 00000DEC  F7 D8				neg eax
 00000DEE  50					push eax

						;calculating 3rd Cofector
 00000DEF  8B 86 00000240 R			mov eax,arr[esi+12]
 00000DF5  8B 9E 00000250 R			mov ebx,arr[esi+28]
 00000DFB  F7 E3				mul ebx
 00000DFD  A3 00000000 R			mov var1,eax
 00000E02  8B 86 00000244 R			mov eax,arr[esi+16]
 00000E08  8B 9E 0000024C R			mov ebx,arr[esi+24]
 00000E0E  F7 E3				mul ebx
 00000E10  A3 00000004 R			mov var2,eax
 00000E15  A1 00000000 R			mov eax,var1
 00000E1A  2B 05 00000004 R			sub eax,var2
 00000E20  50					push eax

						;calculating 4rth Cofector
 00000E21  8B 86 00000238 R			mov eax,arr[esi+4]
 00000E27  8B 9E 00000254 R			mov ebx,arr[esi+32]
 00000E2D  F7 E3				mul ebx
 00000E2F  A3 00000000 R			mov var1,eax
 00000E34  8B 86 0000023C R			mov eax,arr[esi+8]
					
 00000E3A  8B 9E 00000250 R			mov ebx,arr[esi+28]
 00000E40  F7 E3				mul ebx
 00000E42  A3 00000004 R			mov var2,eax
 00000E47  A1 00000000 R			mov eax,var1
 00000E4C  2B 05 00000004 R			sub eax,var2
 00000E52  F7 D8				neg eax
 00000E54  50					push eax

						;calculating 5rth Cofector
 00000E55  8B 86 00000234 R			mov eax,arr[esi]
 00000E5B  8B 9E 00000254 R			mov ebx,arr[esi+32]
 00000E61  F7 E3				mul ebx
 00000E63  A3 00000000 R			mov var1,eax
 00000E68  8B 86 0000023C R			mov eax,arr[esi+8]
 00000E6E  8B 9E 0000024C R			mov ebx,arr[esi+24]
 00000E74  F7 E3				mul ebx
 00000E76  A3 00000004 R			mov var2,eax
 00000E7B  A1 00000000 R			mov eax,var1
 00000E80  2B 05 00000004 R			sub eax,var2
 00000E86  50					push eax

						;calculating 6th Cofector
 00000E87  8B 86 00000234 R			mov eax,arr[esi]
 00000E8D  8B 9E 00000250 R			mov ebx,arr[esi+28]
 00000E93  F7 E3				mul ebx
 00000E95  A3 00000000 R			mov var1,eax
 00000E9A  8B 86 00000238 R			mov eax,arr[esi+4]
 00000EA0  8B 9E 0000024C R			mov ebx,arr[esi+24]
 00000EA6  F7 E3				mul ebx
 00000EA8  A3 00000004 R			mov var2,eax
 00000EAD  A1 00000000 R			mov eax,var1
 00000EB2  2B 05 00000004 R			sub eax,var2
 00000EB8  F7 D8				neg eax
 00000EBA  50					push eax

						;calculating 7th Cofector
 00000EBB  8B 86 00000238 R			mov eax,arr[esi+4]
 00000EC1  8B 9E 00000248 R			mov ebx,arr[esi+20]
 00000EC7  F7 E3				mul ebx
 00000EC9  A3 00000000 R			mov var1,eax
 00000ECE  8B 86 0000023C R			mov eax,arr[esi+8]
 00000ED4  8B 9E 00000244 R			mov ebx,arr[esi+16]
 00000EDA  F7 E3				mul ebx
 00000EDC  A3 00000004 R			mov var2,eax
 00000EE1  A1 00000000 R			mov eax,var1
 00000EE6  2B 05 00000004 R			sub eax,var2
 00000EEC  50					push eax

						;calculating 8th Cofector

 00000EED  8B 86 00000234 R			mov eax,arr[esi]
 00000EF3  8B 9E 00000248 R			mov ebx,arr[esi+20]
 00000EF9  F7 E3				mul ebx
 00000EFB  A3 00000000 R			mov var1,eax
 00000F00  8B 86 0000023C R			mov eax,arr[esi+8]
 00000F06  8B 9E 00000240 R			mov ebx,arr[esi+12]
 00000F0C  F7 E3				mul ebx
 00000F0E  A3 00000004 R			mov var2,eax
 00000F13  A1 00000000 R			mov eax,var1
 00000F18  2B 05 00000004 R			sub eax,var2
 00000F1E  F7 D8				neg eax
 00000F20  50					push eax

						;calculating 9th Cofector
 00000F21  8B 86 00000234 R			mov eax,arr[esi]
 00000F27  8B 9E 00000244 R			mov ebx,arr[esi+16]
 00000F2D  F7 E3				mul ebx
 00000F2F  A3 00000000 R			mov var1,eax
 00000F34  8B 86 00000238 R			mov eax,arr[esi+4]
 00000F3A  8B 9E 00000240 R			mov ebx,arr[esi+12]
 00000F40  F7 E3				mul ebx
 00000F42  A3 00000004 R			mov var2,eax
 00000F47  A1 00000000 R			mov eax,var1
 00000F4C  2B 05 00000004 R			sub eax,var2
 00000F52  50					push eax

 00000F53  BE 00000000				mov esi,0
 00000F58  B9 00000009				mov ecx,9
 00000F5D					Lpop:
 00000F5D  58						pop eax
 00000F5E  89 86 00000234 R				mov arr[esi],eax
 00000F64  83 C6 04					add esi,type arr
 00000F67  E2 F4				loop Lpop

 00000F69  BE 00000000				mov esi,0
 00000F6E  8B 86 00000234 R			mov eax,arr[esi]
 00000F74  87 86 00000254 R			xchg eax,arr[esi+32]
 00000F7A  89 86 00000234 R			mov arr[esi],eax
 00000F80  BE 00000000				mov esi,0
 00000F85  8B 86 00000238 R			mov eax,arr[esi+4]
 00000F8B  87 86 00000248 R			xchg eax,arr[esi+20]
 00000F91  89 86 00000238 R			mov arr[esi+4],eax
 00000F97  BE 00000000				mov esi,0
 00000F9C  8B 86 00000240 R			mov eax,arr[esi+12]
 00000FA2  87 86 00000250 R			xchg eax,arr[esi+28]
 00000FA8  89 86 00000240 R			mov arr[esi+12],eax

 00000FAE  BE 00000000				mov esi,0
 00000FB3  B9 00000009				mov ecx,9
 00000FB8					Lprint:
 00000FB8  8B 86 00000234 R				mov eax,arr[esi]
							.if ecx==6 || ecx==3
 00000FBE  83 F9 06	   *	    cmp    ecx, 006h
 00000FC1  74 05	   *	    je	@C0072
 00000FC3  83 F9 03	   *	    cmp    ecx, 003h
 00000FC6  75 0C	   *	    jne    @C0071
 00000FC8		   *@C0072:
							mwrite<" ",0ah,0dh,0>
 00000BC1		     1		.data		
 00000BC1 20 0A 0D 00 00     1		??0065 BYTE " ",0ah,0dh,0,0	
 00000FC8		     1		.code
 00000FC8  52		     1		push	edx
 00000FC9  BA 00000BC1 R     1		mov	edx,OFFSET ??0065
 00000FCE  E8 00000000 E     1		call	WriteString
 00000FD3  5A		     1		pop	edx
							.endif
 00000FD4		   *@C0071:
							mwrite<"	",0>
 00000BC6		     1		.data		
 00000BC6 09 00 00	     1		??0066 BYTE "	",0,0	
 00000FD4		     1		.code
 00000FD4  52		     1		push	edx
 00000FD5  BA 00000BC6 R     1		mov	edx,OFFSET ??0066
 00000FDA  E8 00000000 E     1		call	WriteString
 00000FDF  5A		     1		pop	edx
 00000FE0  E8 00000000 E				call writeint
 00000FE5  83 C6 04					add esi, type arr
 00000FE8  E2 CE				loop Lprint

 00000FEA  EB 00				jmp LExit
 00000FEC				LExit:
 00000FEC  C3					ret
 00000FED			AdjOf endp 

				;procedure for the Mod of of a given matrix
 00000FED			ModOf proc
					
 00000FED  E8 00000000 E		call crlf
					mwrite<"		1.For 2X2 Matrix ",0ah,0dh,0>
 00000BC9		     1		.data		
 00000BC9 09 09 31 2E 46     1		??0067 BYTE "		1.For 2X2 Matrix ",0ah,0dh,0,0	
	   6F 72 20 32 58
	   32 20 4D 61 74
	   72 69 78 20 0A
	   0D 00 00
 00000FF2		     1		.code
 00000FF2  52		     1		push	edx
 00000FF3  BA 00000BC9 R     1		mov	edx,OFFSET ??0067
 00000FF8  E8 00000000 E     1		call	WriteString
 00000FFD  5A		     1		pop	edx
					mwrite<"		2.For 3X3 Matrix ",0ah,0dh,0>
 00000BE0		     1		.data		
 00000BE0 09 09 32 2E 46     1		??0068 BYTE "		2.For 3X3 Matrix ",0ah,0dh,0,0	
	   6F 72 20 33 58
	   33 20 4D 61 74
	   72 69 78 20 0A
	   0D 00 00
 00000FFE		     1		.code
 00000FFE  52		     1		push	edx
 00000FFF  BA 00000BE0 R     1		mov	edx,OFFSET ??0068
 00001004  E8 00000000 E     1		call	WriteString
 00001009  5A		     1		pop	edx
					mwrite<"		Enter your Choice: ",0ah,0dh,0>
 00000BF7		     1		.data		
 00000BF7 09 09 45 6E 74     1		??0069 BYTE "		Enter your Choice: ",0ah,0dh,0,0	
	   65 72 20 79 6F
	   75 72 20 43 68
	   6F 69 63 65 3A
	   20 0A 0D 00 00
 0000100A		     1		.code
 0000100A  52		     1		push	edx
 0000100B  BA 00000BF7 R     1		mov	edx,OFFSET ??0069
 00001010  E8 00000000 E     1		call	WriteString
 00001015  5A		     1		pop	edx
					mwrite<"---------------------------------------: ",0>
 00000C10		     1		.data		
 00000C10 2D 2D 2D 2D 2D     1		??006A BYTE "---------------------------------------: ",0,0	
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 3A
	   20 00 00
 00001016		     1		.code
 00001016  52		     1		push	edx
 00001017  BA 00000C10 R     1		mov	edx,OFFSET ??006A
 0000101C  E8 00000000 E     1		call	WriteString
 00001021  5A		     1		pop	edx
 00001022  E8 00000000 E		call readint
					.if eax==1
 00001027  83 F8 01	   *	    cmp    eax, 001h
 0000102A  75 04	   *	    jne    @C0074
 0000102C  EB 04				jmp case1
					.else
 0000102E  EB 02	   *	    jmp    @C0076
 00001030		   *@C0074:
 00001030  EB 5E				jmp case2
					.endif
 00001032		   *@C0076:
 00001032				case1:
					mwrite<"Enter the elements of Matrix",0ah,0dh,0>
 00000C3B		     1		.data		
 00000C3B 45 6E 74 65 72     1		??006B BYTE "Enter the elements of Matrix",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 0A 0D
	   00 00
 00001032		     1		.code
 00001032  52		     1		push	edx
 00001033  BA 00000C3B R     1		mov	edx,OFFSET ??006B
 00001038  E8 00000000 E     1		call	WriteString
 0000103D  5A		     1		pop	edx
 0000103E  BE 00000000				mov esi,0
 00001043  B9 00000004				mov ecx,4
 00001048					L11:
 00001048  E8 00000000 E				call readint
 0000104D  89 86 00000234 R				mov arr[esi],eax
 00001053  83 C6 04					add esi,type arr
 00001056  E2 F0				loop L11
 00001058  BE 00000000				mov esi,0
 0000105D  8B 86 00000234 R			mov eax,arr[esi]
 00001063  8B 9E 00000240 R			mov ebx,arr[esi+12]
 00001069  F7 E3				mul ebx
 0000106B  50					push eax
 0000106C  8B 86 00000238 R			mov eax,arr[esi+4]
 00001072  8B 9E 0000023C R			mov ebx,arr[esi+8]
 00001078  F7 E3				mul ebx
 0000107A  A3 00000000 R			mov var1,eax
 0000107F  58					pop eax
 00001080  2B 05 00000000 R			sub eax,var1
 00001086  E8 00000000 E			call writeint
 0000108B  E9 00000114				jmp LExit
 00001090				case2:
					mwrite<"Enter the elements of Matrix",0ah,0dh,0>
 00000C5B		     1		.data		
 00000C5B 45 6E 74 65 72     1		??006C BYTE "Enter the elements of Matrix",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 0A 0D
	   00 00
 00001090		     1		.code
 00001090  52		     1		push	edx
 00001091  BA 00000C5B R     1		mov	edx,OFFSET ??006C
 00001096  E8 00000000 E     1		call	WriteString
 0000109B  5A		     1		pop	edx
 0000109C  BE 00000000				mov esi,0
 000010A1  B9 00000009				mov ecx,9
 000010A6					L21:
 000010A6  E8 00000000 E				call readint
 000010AB  89 86 00000234 R				mov arr[esi],eax
 000010B1  83 C6 04					add esi,type arr
 000010B4  E2 F0				loop L21
 000010B6  BE 00000000				mov esi,0
 000010BB  8B 86 00000234 R			mov eax,arr[esi]
 000010C1  A3 00000000 R			mov var1,eax
 000010C6  8B 86 00000244 R			mov eax,arr[esi+16]
 000010CC  8B 9E 00000254 R			mov ebx,arr[esi+32]
 000010D2  F7 E3				mul ebx
 000010D4  A3 00000004 R			mov var2,eax
 000010D9  8B 86 00000248 R			mov eax,arr[esi+20]
 000010DF  8B 9E 00000250 R			mov ebx,arr[esi+28]
 000010E5  F7 E3				mul ebx
 000010E7  A3 00000008 R			mov var3,eax
 000010EC  A1 00000004 R			mov eax,var2
 000010F1  2B 05 00000008 R			sub eax,var3
 000010F7  F7 25 00000000 R			mul var1
 000010FD  50					push eax

 000010FE  8B 86 00000238 R			mov eax,arr[esi+4]
 00001104  F7 D8				neg eax
 00001106  A3 00000000 R			mov var1,eax
 0000110B  8B 86 00000240 R			mov eax,arr[esi+12]
 00001111  8B 9E 00000254 R			mov ebx,arr[esi+32]
 00001117  F7 E3				mul ebx
 00001119  A3 00000004 R			mov var2,eax
 0000111E  8B 86 00000248 R			mov eax,arr[esi+20]
 00001124  8B 9E 0000024C R			mov ebx,arr[esi+24]
 0000112A  F7 E3				mul ebx
 0000112C  A3 00000008 R			mov var3,eax
 00001131  A1 00000004 R			mov eax,var2
 00001136  2B 05 00000008 R			sub eax,var3
 0000113C  F7 25 00000000 R			mul var1
 00001142  50					push eax

 00001143  8B 86 0000023C R			mov eax,arr[esi+8]
 00001149  A3 00000000 R			mov var1,eax
 0000114E  8B 86 00000240 R			mov eax,arr[esi+12]
 00001154  8B 9E 00000250 R			mov ebx,arr[esi+28]
 0000115A  F7 E3				mul ebx
 0000115C  A3 00000004 R			mov var2,eax
 00001161  8B 86 00000244 R			mov eax,arr[esi+16]
 00001167  8B 9E 0000024C R			mov ebx,arr[esi+24]
 0000116D  F7 E3				mul ebx
 0000116F  A3 00000008 R			mov var3,eax
 00001174  A1 00000004 R			mov eax,var2
 00001179  2B 05 00000008 R			sub eax,var3
 0000117F  F7 25 00000000 R			mul var1
 00001185  A3 00000000 R			mov var1,eax
 0000118A  58					pop eax
 0000118B  A3 00000004 R			mov var2,eax
 00001190  58					pop eax
 00001191  03 05 00000004 R			add eax,var2
 00001197  03 05 00000000 R			add eax,var1
 0000119D  E8 00000000 E			call writeint
 000011A2  EB 00			jmp LExit
 000011A4				LExit:
 000011A4  C3				ret
 000011A5			ModOf endp

				;procedure for the transpose of a given matrix
 000011A5			Transpose proc
 000011A5  E8 00000000 E	call crlf
 000011AA  BA 00000166 R		mov edx,offset selectString
 000011AF  E8 00000000 E		call writestring
 000011B4  E8 00000000 E		call crlf
					mwrite<"Enter your choice << ",0>
 00000C7B		     1		.data		
 00000C7B 45 6E 74 65 72     1		??006D BYTE "Enter your choice << ",0,0	
	   20 79 6F 75 72
	   20 63 68 6F 69
	   63 65 20 3C 3C
	   20 00 00
 000011B9		     1		.code
 000011B9  52		     1		push	edx
 000011BA  BA 00000C7B R     1		mov	edx,OFFSET ??006D
 000011BF  E8 00000000 E     1		call	WriteString
 000011C4  5A		     1		pop	edx
 000011C5  E8 00000000 E		call readint 
					mwrite<"----------------------",0ah,0dh>
 00000C92		     1		.data		
 00000C92 2D 2D 2D 2D 2D     1		??006E BYTE "----------------------",0ah,0dh,0	
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 0A 0D 00
 000011CA		     1		.code
 000011CA  52		     1		push	edx
 000011CB  BA 00000C92 R     1		mov	edx,OFFSET ??006E
 000011D0  E8 00000000 E     1		call	WriteString
 000011D5  5A		     1		pop	edx
					.if eax==1
 000011D6  83 F8 01	   *	    cmp    eax, 001h
 000011D9  75 04	   *	    jne    @C0077
 000011DB  EB 60			jmp case1
					.elseif eax==2
 000011DD  EB 5E	   *	    jmp    @C0079
 000011DF		   *@C0077:
 000011DF  83 F8 02	   *	    cmp    eax, 002h
 000011E2  75 07	   *	    jne    @C007A
 000011E4  E9 000000AE			jmp case2
					.elseif  eax==3
 000011E9  EB 52	   *	    jmp    @C007C
 000011EB		   *@C007A:
 000011EB  83 F8 03	   *	    cmp    eax, 003h
 000011EE  75 07	   *	    jne    @C007D
 000011F0  E9 00000110			jmp case3
					.elseif eax==4
 000011F5  EB 46	   *	    jmp    @C007F
 000011F7		   *@C007D:
 000011F7  83 F8 04	   *	    cmp    eax, 004h
 000011FA  75 07	   *	    jne    @C0080
 000011FC  E9 00000177			jmp case4
					.elseif eax==5
 00001201  EB 3A	   *	    jmp    @C0082
 00001203		   *@C0080:
 00001203  83 F8 05	   *	    cmp    eax, 005h
 00001206  75 07	   *	    jne    @C0083
 00001208  E9 000001C8			jmp case5
					.elseif eax==6
 0000120D  EB 2E	   *	    jmp    @C0085
 0000120F		   *@C0083:
 0000120F  83 F8 06	   *	    cmp    eax, 006h
 00001212  75 07	   *	    jne    @C0086
 00001214  E9 0000023C			jmp case6
					.elseif eax==7
 00001219  EB 22	   *	    jmp    @C0088
 0000121B		   *@C0086:
 0000121B  83 F8 07	   *	    cmp    eax, 007h
 0000121E  75 07	   *	    jne    @C0089
 00001220  E9 000002D9			jmp case7
					.elseif eax==8
 00001225  EB 16	   *	    jmp    @C008B
 00001227		   *@C0089:
 00001227  83 F8 08	   *	    cmp    eax, 008h
 0000122A  75 07	   *	    jne    @C008C
 0000122C  E9 0000032A			jmp case8
					.elseif eax==9
 00001231  EB 0A	   *	    jmp    @C008E
 00001233		   *@C008C:
 00001233  83 F8 09	   *	    cmp    eax, 009h
 00001236  75 05	   *	    jne    @C008F
 00001238  E9 000003C2			jmp case9
					.endif
 0000123D		   *@C008F:
 0000123D		   *@C008E:
 0000123D		   *@C008B:
 0000123D		   *@C0088:
 0000123D		   *@C0085:
 0000123D		   *@C0082:
 0000123D		   *@C007F:
 0000123D		   *@C007C:
 0000123D		   *@C0079:
 0000123D				case1:
						mwrite<"Enter the elements of Matrix",0ah,0dh,0>
 00000CAB		     1		.data		
 00000CAB 45 6E 74 65 72     1		??006F BYTE "Enter the elements of Matrix",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 0A 0D
	   00 00
 0000123D		     1		.code
 0000123D  52		     1		push	edx
 0000123E  BA 00000CAB R     1		mov	edx,OFFSET ??006F
 00001243  E8 00000000 E     1		call	WriteString
 00001248  5A		     1		pop	edx
 00001249  BE 00000000				mov esi,0
 0000124E  B9 00000001				mov ecx,1
 00001253					L11:
 00001253  E8 00000000 E				call readint
 00001258  89 86 00000234 R				mov arr[esi],eax
 0000125E  83 C6 04					add esi,type arr
 00001261  E2 F0				loop L11

						mwrite<"The Transpose of the given matrix is",0ah,0dh,0>
 00000CCB		     1		.data		
 00000CCB 54 68 65 20 54     1		??0070 BYTE "The Transpose of the given matrix is",0ah,0dh,0,0	
	   72 61 6E 73 70
	   6F 73 65 20 6F
	   66 20 74 68 65
	   20 67 69 76 65
	   6E 20 6D 61 74
	   72 69 78 20 69
	   73 0A 0D 00 00
 00001263		     1		.code
 00001263  52		     1		push	edx
 00001264  BA 00000CCB R     1		mov	edx,OFFSET ??0070
 00001269  E8 00000000 E     1		call	WriteString
 0000126E  5A		     1		pop	edx
 0000126F  B9 00000001				mov ecx,1
 00001274  BE 00000000				mov esi,0
 00001279					L12:
 00001279  8B 86 00000234 R				mov eax,arr[esi]
							mwrite<"	",0>
 00000CF3		     1		.data		
 00000CF3 09 00 00	     1		??0071 BYTE "	",0,0	
 0000127F		     1		.code
 0000127F  52		     1		push	edx
 00001280  BA 00000CF3 R     1		mov	edx,OFFSET ??0071
 00001285  E8 00000000 E     1		call	WriteString
 0000128A  5A		     1		pop	edx
 0000128B  E8 00000000 E				call writeint
 00001290  E2 E7				loop L12
 00001292  E9 0000041A				jmp LExit
 00001297				case2:
						mwrite<"Enter the elements of Matrix ",0ah,0dh,0>
 00000CF6		     1		.data		
 00000CF6 45 6E 74 65 72     1		??0072 BYTE "Enter the elements of Matrix ",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 0A
	   0D 00 00
 00001297		     1		.code
 00001297  52		     1		push	edx
 00001298  BA 00000CF6 R     1		mov	edx,OFFSET ??0072
 0000129D  E8 00000000 E     1		call	WriteString
 000012A2  5A		     1		pop	edx
 000012A3  BE 00000000				mov esi,0
 000012A8  B9 00000002				mov ecx,2
 000012AD					L21:
 000012AD  E8 00000000 E				call readint
 000012B2  89 86 00000234 R				mov arr[esi],eax
 000012B8  83 C6 04					add esi,type arr
 000012BB  E2 F0				loop L21

						mwrite<"The Transpose of the given matrix is",0ah,0dh,0>
 00000D17		     1		.data		
 00000D17 54 68 65 20 54     1		??0073 BYTE "The Transpose of the given matrix is",0ah,0dh,0,0	
	   72 61 6E 73 70
	   6F 73 65 20 6F
	   66 20 74 68 65
	   20 67 69 76 65
	   6E 20 6D 61 74
	   72 69 78 20 69
	   73 0A 0D 00 00
 000012BD		     1		.code
 000012BD  52		     1		push	edx
 000012BE  BA 00000D17 R     1		mov	edx,OFFSET ??0073
 000012C3  E8 00000000 E     1		call	WriteString
 000012C8  5A		     1		pop	edx
 000012C9  B9 00000002				mov ecx,2
 000012CE  BE 00000000				mov esi,0
 000012D3					L22:
 000012D3  8B 86 00000234 R				mov eax,arr[esi]
							.if ecx==1
 000012D9  83 F9 01	   *	    cmp    ecx, 001h
 000012DC  75 0C	   *	    jne    @C0091
							mwrite<"	",0ah,0dh,0>
 00000D3F		     1		.data		
 00000D3F 09 0A 0D 00 00     1		??0074 BYTE "	",0ah,0dh,0,0	
 000012DE		     1		.code
 000012DE  52		     1		push	edx
 000012DF  BA 00000D3F R     1		mov	edx,OFFSET ??0074
 000012E4  E8 00000000 E     1		call	WriteString
 000012E9  5A		     1		pop	edx
							.endif
 000012EA		   *@C0091:
							mwrite<"	",0>
 00000D44		     1		.data		
 00000D44 09 00 00	     1		??0075 BYTE "	",0,0	
 000012EA		     1		.code
 000012EA  52		     1		push	edx
 000012EB  BA 00000D44 R     1		mov	edx,OFFSET ??0075
 000012F0  E8 00000000 E     1		call	WriteString
 000012F5  5A		     1		pop	edx
 000012F6  E8 00000000 E				call writeint
 000012FB  83 C6 04					add esi,type arr
 000012FE  E2 D3				loop L22
 00001300  E9 000003AC				jmp LExit
 00001305				case3:
						mwrite<"Enter the elements of Matrix ",0ah,0dh,0>
 00000D47		     1		.data		
 00000D47 45 6E 74 65 72     1		??0076 BYTE "Enter the elements of Matrix ",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 0A
	   0D 00 00
 00001305		     1		.code
 00001305  52		     1		push	edx
 00001306  BA 00000D47 R     1		mov	edx,OFFSET ??0076
 0000130B  E8 00000000 E     1		call	WriteString
 00001310  5A		     1		pop	edx
 00001311  BE 00000000				mov esi,0
 00001316  B9 00000003				mov ecx,3
 0000131B					L31:
 0000131B  E8 00000000 E				call readint
 00001320  89 86 00000234 R				mov arr[esi],eax
 00001326  83 C6 04					add esi,type arr
 00001329  E2 F0				loop L31

						mwrite<"The Transpose of the given matrix is",0ah,0dh,0>
 00000D68		     1		.data		
 00000D68 54 68 65 20 54     1		??0077 BYTE "The Transpose of the given matrix is",0ah,0dh,0,0	
	   72 61 6E 73 70
	   6F 73 65 20 6F
	   66 20 74 68 65
	   20 67 69 76 65
	   6E 20 6D 61 74
	   72 69 78 20 69
	   73 0A 0D 00 00
 0000132B		     1		.code
 0000132B  52		     1		push	edx
 0000132C  BA 00000D68 R     1		mov	edx,OFFSET ??0077
 00001331  E8 00000000 E     1		call	WriteString
 00001336  5A		     1		pop	edx
 00001337  B9 00000003				mov ecx,3
 0000133C  BE 00000000				mov esi,0
 00001341					L32:
 00001341  8B 86 00000234 R				mov eax,arr[esi]
							.if ecx==1 || ecx==2
 00001347  83 F9 01	   *	    cmp    ecx, 001h
 0000134A  74 05	   *	    je	@C0094
 0000134C  83 F9 02	   *	    cmp    ecx, 002h
 0000134F  75 0C	   *	    jne    @C0093
 00001351		   *@C0094:
							mwrite<"	",0ah,0dh,0>
 00000D90		     1		.data		
 00000D90 09 0A 0D 00 00     1		??0078 BYTE "	",0ah,0dh,0,0	
 00001351		     1		.code
 00001351  52		     1		push	edx
 00001352  BA 00000D90 R     1		mov	edx,OFFSET ??0078
 00001357  E8 00000000 E     1		call	WriteString
 0000135C  5A		     1		pop	edx
							.endif
 0000135D		   *@C0093:
							mwrite<"	",0>
 00000D95		     1		.data		
 00000D95 09 00 00	     1		??0079 BYTE "	",0,0	
 0000135D		     1		.code
 0000135D  52		     1		push	edx
 0000135E  BA 00000D95 R     1		mov	edx,OFFSET ??0079
 00001363  E8 00000000 E     1		call	WriteString
 00001368  5A		     1		pop	edx
 00001369  E8 00000000 E				call writeint
 0000136E  83 C6 04					add esi,type arr
 00001371  E2 CE				loop L32
 00001373  E9 00000339				jmp LExit

 00001378				case4:
						mwrite<"Enter the elements of Matrix",0ah,0dh,0>
 00000D98		     1		.data		
 00000D98 45 6E 74 65 72     1		??007A BYTE "Enter the elements of Matrix",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 0A 0D
	   00 00
 00001378		     1		.code
 00001378  52		     1		push	edx
 00001379  BA 00000D98 R     1		mov	edx,OFFSET ??007A
 0000137E  E8 00000000 E     1		call	WriteString
 00001383  5A		     1		pop	edx
 00001384  BE 00000000				mov esi,0
 00001389  B9 00000002				mov ecx,2
 0000138E					L41:
 0000138E  E8 00000000 E				call readint
 00001393  89 86 00000234 R				mov arr[esi],eax
 00001399  83 C6 04					add esi,type arr
 0000139C  E2 F0				loop L41

						mwrite<"The Transpose of the given matrix is",0ah,0dh,0>
 00000DB8		     1		.data		
 00000DB8 54 68 65 20 54     1		??007B BYTE "The Transpose of the given matrix is",0ah,0dh,0,0	
	   72 61 6E 73 70
	   6F 73 65 20 6F
	   66 20 74 68 65
	   20 67 69 76 65
	   6E 20 6D 61 74
	   72 69 78 20 69
	   73 0A 0D 00 00
 0000139E		     1		.code
 0000139E  52		     1		push	edx
 0000139F  BA 00000DB8 R     1		mov	edx,OFFSET ??007B
 000013A4  E8 00000000 E     1		call	WriteString
 000013A9  5A		     1		pop	edx
 000013AA  B9 00000002				mov ecx,2
 000013AF  BE 00000000				mov esi,0
 000013B4					L42:
 000013B4  8B 86 00000234 R				mov eax,arr[esi]
							mwrite<"	",0>
 00000DE0		     1		.data		
 00000DE0 09 00 00	     1		??007C BYTE "	",0,0	
 000013BA		     1		.code
 000013BA  52		     1		push	edx
 000013BB  BA 00000DE0 R     1		mov	edx,OFFSET ??007C
 000013C0  E8 00000000 E     1		call	WriteString
 000013C5  5A		     1		pop	edx
 000013C6  E8 00000000 E				call writeint
 000013CB  83 C6 04					add esi,type arr
 000013CE  E2 E4				loop L42
 000013D0  E9 000002DC				jmp LExit
 000013D5				case5:
					mwrite<"Enter the elements of Matrix",0ah,0dh,0>
 00000DE3		     1		.data		
 00000DE3 45 6E 74 65 72     1		??007D BYTE "Enter the elements of Matrix",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 0A 0D
	   00 00
 000013D5		     1		.code
 000013D5  52		     1		push	edx
 000013D6  BA 00000DE3 R     1		mov	edx,OFFSET ??007D
 000013DB  E8 00000000 E     1		call	WriteString
 000013E0  5A		     1		pop	edx
 000013E1  BE 00000000				mov esi,0
 000013E6  B9 00000004				mov ecx,4
 000013EB					L51:
 000013EB  E8 00000000 E				call readint
 000013F0  89 86 00000234 R				mov arr[esi],eax
 000013F6  83 C6 04					add esi,type arr
 000013F9  E2 F0				loop L51

						mwrite<"The Transpose of the given matrix is",0ah,0dh,0>
 00000E03		     1		.data		
 00000E03 54 68 65 20 54     1		??007E BYTE "The Transpose of the given matrix is",0ah,0dh,0,0	
	   72 61 6E 73 70
	   6F 73 65 20 6F
	   66 20 74 68 65
	   20 67 69 76 65
	   6E 20 6D 61 74
	   72 69 78 20 69
	   73 0A 0D 00 00
 000013FB		     1		.code
 000013FB  52		     1		push	edx
 000013FC  BA 00000E03 R     1		mov	edx,OFFSET ??007E
 00001401  E8 00000000 E     1		call	WriteString
 00001406  5A		     1		pop	edx
 00001407  B9 00000004				mov ecx,4
 0000140C  BE 00000000				mov esi,0
 00001411  8B 96 00000238 R			mov edx,arr[esi+4]
 00001417  87 96 0000023C R			xchg arr[esi+8],edx
 0000141D  89 96 00000238 R			mov arr[esi+4],edx
 00001423					L52:
 00001423  8B 86 00000234 R				mov eax,arr[esi]
							.if ecx==2
 00001429  83 F9 02	   *	    cmp    ecx, 002h
 0000142C  75 0C	   *	    jne    @C0096
							mwrite<"	",0ah,0dh,0>
 00000E2B		     1		.data		
 00000E2B 09 0A 0D 00 00     1		??007F BYTE "	",0ah,0dh,0,0	
 0000142E		     1		.code
 0000142E  52		     1		push	edx
 0000142F  BA 00000E2B R     1		mov	edx,OFFSET ??007F
 00001434  E8 00000000 E     1		call	WriteString
 00001439  5A		     1		pop	edx
							.endif
 0000143A		   *@C0096:
							mwrite<"	",0>
 00000E30		     1		.data		
 00000E30 09 00 00	     1		??0080 BYTE "	",0,0	
 0000143A		     1		.code
 0000143A  52		     1		push	edx
 0000143B  BA 00000E30 R     1		mov	edx,OFFSET ??0080
 00001440  E8 00000000 E     1		call	WriteString
 00001445  5A		     1		pop	edx
 00001446  E8 00000000 E				call writeint
 0000144B  83 C6 04					add esi,type arr
 0000144E  E2 D3				loop L52
 00001450  E9 0000025C				jmp LExit

 00001455				case6:
					mwrite<"Enter the elements of Matrix",0ah,0dh,0>
 00000E33		     1		.data		
 00000E33 45 6E 74 65 72     1		??0081 BYTE "Enter the elements of Matrix",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 0A 0D
	   00 00
 00001455		     1		.code
 00001455  52		     1		push	edx
 00001456  BA 00000E33 R     1		mov	edx,OFFSET ??0081
 0000145B  E8 00000000 E     1		call	WriteString
 00001460  5A		     1		pop	edx
 00001461  BE 00000000				mov esi,0
 00001466  B9 00000006				mov ecx,6
 0000146B					L61:
 0000146B  E8 00000000 E				call readint
 00001470  89 86 00000234 R				mov arr[esi],eax
 00001476  83 C6 04					add esi,type arr
 00001479  E2 F0				loop L61

						mwrite<"The Transpose of the given matrix is",0ah,0dh,0>
 00000E53		     1		.data		
 00000E53 54 68 65 20 54     1		??0082 BYTE "The Transpose of the given matrix is",0ah,0dh,0,0	
	   72 61 6E 73 70
	   6F 73 65 20 6F
	   66 20 74 68 65
	   20 67 69 76 65
	   6E 20 6D 61 74
	   72 69 78 20 69
	   73 0A 0D 00 00
 0000147B		     1		.code
 0000147B  52		     1		push	edx
 0000147C  BA 00000E53 R     1		mov	edx,OFFSET ??0082
 00001481  E8 00000000 E     1		call	WriteString
 00001486  5A		     1		pop	edx
 00001487  B9 00000006				mov ecx,6
 0000148C  BE 00000000				mov esi,0
 00001491  8B 96 00000238 R			mov edx,arr[esi+4]
 00001497  87 96 00000240 R			xchg arr[esi+12],edx
 0000149D  89 96 00000238 R			mov arr[esi+4],edx
 000014A3  8B 96 0000023C R			mov edx,arr[esi+8]
 000014A9  87 96 00000240 R			xchg arr[esi+12],edx
 000014AF  89 96 0000023C R			mov arr[esi+8],edx
 000014B5  8B 96 00000240 R			mov edx,arr[esi+12]
 000014BB  87 96 00000244 R			xchg arr[esi+16],edx
 000014C1  89 96 00000240 R			mov arr[esi+12],edx
 000014C7					L62:
 000014C7  8B 86 00000234 R				mov eax,arr[esi]
							.if ecx==4 || ecx==2
 000014CD  83 F9 04	   *	    cmp    ecx, 004h
 000014D0  74 05	   *	    je	@C0099
 000014D2  83 F9 02	   *	    cmp    ecx, 002h
 000014D5  75 0C	   *	    jne    @C0098
 000014D7		   *@C0099:
							mwrite<"	",0ah,0dh,0>
 00000E7B		     1		.data		
 00000E7B 09 0A 0D 00 00     1		??0083 BYTE "	",0ah,0dh,0,0	
 000014D7		     1		.code
 000014D7  52		     1		push	edx
 000014D8  BA 00000E7B R     1		mov	edx,OFFSET ??0083
 000014DD  E8 00000000 E     1		call	WriteString
 000014E2  5A		     1		pop	edx
							.endif
 000014E3		   *@C0098:
							mwrite<"	",0>
 00000E80		     1		.data		
 00000E80 09 00 00	     1		??0084 BYTE "	",0,0	
 000014E3		     1		.code
 000014E3  52		     1		push	edx
 000014E4  BA 00000E80 R     1		mov	edx,OFFSET ??0084
 000014E9  E8 00000000 E     1		call	WriteString
 000014EE  5A		     1		pop	edx
 000014EF  E8 00000000 E				call writeint
 000014F4  83 C6 04					add esi,type arr
 000014F7  E2 CE				loop L62
 000014F9  E9 000001B3				jmp LExit

 000014FE				case7:
						mwrite<"Enter the elements of Matrix",0ah,0dh,0>
 00000E83		     1		.data		
 00000E83 45 6E 74 65 72     1		??0085 BYTE "Enter the elements of Matrix",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 0A 0D
	   00 00
 000014FE		     1		.code
 000014FE  52		     1		push	edx
 000014FF  BA 00000E83 R     1		mov	edx,OFFSET ??0085
 00001504  E8 00000000 E     1		call	WriteString
 00001509  5A		     1		pop	edx
 0000150A  BE 00000000				mov esi,0
 0000150F  B9 00000003				mov ecx,3
 00001514					L71:
 00001514  E8 00000000 E				call readint
 00001519  89 86 00000234 R				mov arr[esi],eax
 0000151F  83 C6 04					add esi,type arr
 00001522  E2 F0				loop L71


						mwrite<"The Transpose of the given matrix is",0ah,0dh,0>
 00000EA3		     1		.data		
 00000EA3 54 68 65 20 54     1		??0086 BYTE "The Transpose of the given matrix is",0ah,0dh,0,0	
	   72 61 6E 73 70
	   6F 73 65 20 6F
	   66 20 74 68 65
	   20 67 69 76 65
	   6E 20 6D 61 74
	   72 69 78 20 69
	   73 0A 0D 00 00
 00001524		     1		.code
 00001524  52		     1		push	edx
 00001525  BA 00000EA3 R     1		mov	edx,OFFSET ??0086
 0000152A  E8 00000000 E     1		call	WriteString
 0000152F  5A		     1		pop	edx
 00001530  B9 00000003				mov ecx,3
 00001535  BE 00000000				mov esi,0
 0000153A					L73:
 0000153A  8B 86 00000234 R				mov eax,arr[esi]
							mwrite<"	",0>
 00000ECB		     1		.data		
 00000ECB 09 00 00	     1		??0087 BYTE "	",0,0	
 00001540		     1		.code
 00001540  52		     1		push	edx
 00001541  BA 00000ECB R     1		mov	edx,OFFSET ??0087
 00001546  E8 00000000 E     1		call	WriteString
 0000154B  5A		     1		pop	edx
 0000154C  E8 00000000 E				call writeint
 00001551  83 C6 04					add esi,type arr
 00001554  E2 E4				loop L73
 00001556  E9 00000156				jmp LExit

 0000155B				case8:
						mwrite<"Enter the elements of Matrix ",0ah,0dh,0>
 00000ECE		     1		.data		
 00000ECE 45 6E 74 65 72     1		??0088 BYTE "Enter the elements of Matrix ",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 0A
	   0D 00 00
 0000155B		     1		.code
 0000155B  52		     1		push	edx
 0000155C  BA 00000ECE R     1		mov	edx,OFFSET ??0088
 00001561  E8 00000000 E     1		call	WriteString
 00001566  5A		     1		pop	edx
 00001567  BE 00000000				mov esi,0
 0000156C  B9 00000006				mov ecx,6
 00001571					L81:
 00001571  E8 00000000 E				call readint
 00001576  89 86 00000234 R				mov arr[esi],eax
 0000157C  83 C6 04					add esi,type arr
 0000157F  E2 F0				loop L81

						mwrite<"The Transpose of the given matrix is",0ah,0dh,0>
 00000EEF		     1		.data		
 00000EEF 54 68 65 20 54     1		??0089 BYTE "The Transpose of the given matrix is",0ah,0dh,0,0	
	   72 61 6E 73 70
	   6F 73 65 20 6F
	   66 20 74 68 65
	   20 67 69 76 65
	   6E 20 6D 61 74
	   72 69 78 20 69
	   73 0A 0D 00 00
 00001581		     1		.code
 00001581  52		     1		push	edx
 00001582  BA 00000EEF R     1		mov	edx,OFFSET ??0089
 00001587  E8 00000000 E     1		call	WriteString
 0000158C  5A		     1		pop	edx
 0000158D  B9 00000006				mov ecx,6
 00001592  BE 00000000				mov esi,0
 00001597  8B 96 00000238 R			mov edx,arr[esi+4]
 0000159D  87 96 0000023C R			xchg arr[esi+8],edx
 000015A3  89 96 00000238 R			mov arr[esi+4],edx
 000015A9  8B 96 00000240 R			mov edx,arr[esi+12]
 000015AF  87 96 00000244 R			xchg arr[esi+16],edx
 000015B5  89 96 00000240 R			mov arr[esi+12],edx
 000015BB  8B 96 0000023C R			mov edx,arr[esi+8]
 000015C1  87 96 00000240 R			xchg arr[esi+12],edx
 000015C7  89 96 0000023C R			mov arr[esi+8],edx
 000015CD					L83:
 000015CD  8B 86 00000234 R				mov eax,arr[esi]
							.if ecx==3
 000015D3  83 F9 03	   *	    cmp    ecx, 003h
 000015D6  75 0C	   *	    jne    @C009B
							mwrite<"	",0ah,0dh,0>
 00000F17		     1		.data		
 00000F17 09 0A 0D 00 00     1		??008A BYTE "	",0ah,0dh,0,0	
 000015D8		     1		.code
 000015D8  52		     1		push	edx
 000015D9  BA 00000F17 R     1		mov	edx,OFFSET ??008A
 000015DE  E8 00000000 E     1		call	WriteString
 000015E3  5A		     1		pop	edx
							.endif
 000015E4		   *@C009B:
							mwrite<"	",0>
 00000F1C		     1		.data		
 00000F1C 09 00 00	     1		??008B BYTE "	",0,0	
 000015E4		     1		.code
 000015E4  52		     1		push	edx
 000015E5  BA 00000F1C R     1		mov	edx,OFFSET ??008B
 000015EA  E8 00000000 E     1		call	WriteString
 000015EF  5A		     1		pop	edx
 000015F0  E8 00000000 E				call writeint
 000015F5  83 C6 04					add esi,type arr
 000015F8  E2 D3				loop L83
 000015FA  E9 000000B2				jmp LExit

 000015FF				case9:
						mwrite<"Enter the elements of Matrix 01",0ah,0dh,0>
 00000F1F		     1		.data		
 00000F1F 45 6E 74 65 72     1		??008C BYTE "Enter the elements of Matrix 01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 20 30
	   31 0A 0D 00 00
 000015FF		     1		.code
 000015FF  52		     1		push	edx
 00001600  BA 00000F1F R     1		mov	edx,OFFSET ??008C
 00001605  E8 00000000 E     1		call	WriteString
 0000160A  5A		     1		pop	edx
 0000160B  BE 00000000				mov esi,0
 00001610  B9 00000009				mov ecx,9
 00001615					L91:
 00001615  E8 00000000 E				call readint
 0000161A  89 86 00000234 R				mov arr[esi],eax
 00001620  83 C6 04					add esi,type arr
 00001623  E2 F0				loop L91

						mwrite<"The Transpose of the given matrix is ",0ah,0dh,0>
 00000F42		     1		.data		
 00000F42 54 68 65 20 54     1		??008D BYTE "The Transpose of the given matrix is ",0ah,0dh,0,0	
	   72 61 6E 73 70
	   6F 73 65 20 6F
	   66 20 74 68 65
	   20 67 69 76 65
	   6E 20 6D 61 74
	   72 69 78 20 69
	   73 20 0A 0D 00
	   00
 00001625		     1		.code
 00001625  52		     1		push	edx
 00001626  BA 00000F42 R     1		mov	edx,OFFSET ??008D
 0000162B  E8 00000000 E     1		call	WriteString
 00001630  5A		     1		pop	edx
 00001631  B9 00000009				mov ecx,9
 00001636  BE 00000000				mov esi,0
 0000163B  8B 96 00000238 R			mov edx,arr[esi+4]
 00001641  87 96 00000240 R			xchg arr[esi+12],edx
 00001647  89 96 00000238 R			mov arr[esi+4],edx
 0000164D  8B 96 0000023C R			mov edx,arr[esi+8]
 00001653  87 96 0000024C R			xchg arr[esi+24],edx
 00001659  89 96 0000023C R			mov arr[esi+8],edx
 0000165F  8B 96 00000248 R			mov edx,arr[esi+20]
 00001665  87 96 00000250 R			xchg arr[esi+28],edx
 0000166B  89 96 00000248 R			mov arr[esi+20],edx
 00001671					L93:
 00001671  8B 86 00000234 R				mov eax,arr[esi]
							mwrite<"	",0>
 00000F6B		     1		.data		
 00000F6B 09 00 00	     1		??008E BYTE "	",0,0	
 00001677		     1		.code
 00001677  52		     1		push	edx
 00001678  BA 00000F6B R     1		mov	edx,OFFSET ??008E
 0000167D  E8 00000000 E     1		call	WriteString
 00001682  5A		     1		pop	edx
							.if ecx==6 || ecx==3
 00001683  83 F9 06	   *	    cmp    ecx, 006h
 00001686  74 05	   *	    je	@C009E
 00001688  83 F9 03	   *	    cmp    ecx, 003h
 0000168B  75 18	   *	    jne    @C009D
 0000168D		   *@C009E:
								mwrite<0ah,0dh,0>
 00000F6E		     1		.data		
 00000F6E 0A 0D 00 00	     1		??008F BYTE 0ah,0dh,0,0	
 0000168D		     1		.code
 0000168D  52		     1		push	edx
 0000168E  BA 00000F6E R     1		mov	edx,OFFSET ??008F
 00001693  E8 00000000 E     1		call	WriteString
 00001698  5A		     1		pop	edx
								mwrite<"	",0>
 00000F72		     1		.data		
 00000F72 09 00 00	     1		??0090 BYTE "	",0,0	
 00001699		     1		.code
 00001699  52		     1		push	edx
 0000169A  BA 00000F72 R     1		mov	edx,OFFSET ??0090
 0000169F  E8 00000000 E     1		call	WriteString
 000016A4  5A		     1		pop	edx
							.endif
 000016A5		   *@C009D:
 000016A5  E8 00000000 E				call writeint
 000016AA  83 C6 04					add esi,type arr
 000016AD  E2 C2				loop L93
 000016AF  EB 00				jmp LExit
 000016B1				LExit:
 000016B1  C3			ret
 000016B2			Transpose endp

				;procedure for the multiplication of a two matrices
 000016B2			Multiplication proc
 000016B2  E8 00000000 E		call crlf
					mwrite<"	For Square Matrix Only ",0ah,0dh,0>
 00000F75		     1		.data		
 00000F75 09 46 6F 72 20     1		??0091 BYTE "	For Square Matrix Only ",0ah,0dh,0,0	
	   53 71 75 61 72
	   65 20 4D 61 74
	   72 69 78 20 4F
	   6E 6C 79 20 0A
	   0D 00 00
 000016B7		     1		.code
 000016B7  52		     1		push	edx
 000016B8  BA 00000F75 R     1		mov	edx,OFFSET ??0091
 000016BD  E8 00000000 E     1		call	WriteString
 000016C2  5A		     1		pop	edx
					mwrite<"---------------------------------------: ",0ah,0dh,0>
 00000F91		     1		.data		
 00000F91 2D 2D 2D 2D 2D     1		??0092 BYTE "---------------------------------------: ",0ah,0dh,0,0	
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 3A
	   20 0A 0D 00 00
 000016C3		     1		.code
 000016C3  52		     1		push	edx
 000016C4  BA 00000F91 R     1		mov	edx,OFFSET ??0092
 000016C9  E8 00000000 E     1		call	WriteString
 000016CE  5A		     1		pop	edx
					mwrite<"		1.For 2X2 Matrix ",0ah,0dh,0>
 00000FBE		     1		.data		
 00000FBE 09 09 31 2E 46     1		??0093 BYTE "		1.For 2X2 Matrix ",0ah,0dh,0,0	
	   6F 72 20 32 58
	   32 20 4D 61 74
	   72 69 78 20 0A
	   0D 00 00
 000016CF		     1		.code
 000016CF  52		     1		push	edx
 000016D0  BA 00000FBE R     1		mov	edx,OFFSET ??0093
 000016D5  E8 00000000 E     1		call	WriteString
 000016DA  5A		     1		pop	edx
					mwrite<"		2.For 3X3 Matrix ",0ah,0dh,0>
 00000FD5		     1		.data		
 00000FD5 09 09 32 2E 46     1		??0094 BYTE "		2.For 3X3 Matrix ",0ah,0dh,0,0	
	   6F 72 20 33 58
	   33 20 4D 61 74
	   72 69 78 20 0A
	   0D 00 00
 000016DB		     1		.code
 000016DB  52		     1		push	edx
 000016DC  BA 00000FD5 R     1		mov	edx,OFFSET ??0094
 000016E1  E8 00000000 E     1		call	WriteString
 000016E6  5A		     1		pop	edx
					mwrite<"		Enter your Choice: ",0ah,0dh,0>
 00000FEC		     1		.data		
 00000FEC 09 09 45 6E 74     1		??0095 BYTE "		Enter your Choice: ",0ah,0dh,0,0	
	   65 72 20 79 6F
	   75 72 20 43 68
	   6F 69 63 65 3A
	   20 0A 0D 00 00
 000016E7		     1		.code
 000016E7  52		     1		push	edx
 000016E8  BA 00000FEC R     1		mov	edx,OFFSET ??0095
 000016ED  E8 00000000 E     1		call	WriteString
 000016F2  5A		     1		pop	edx
					mwrite<"---------------------------------------: ",0ah,0dh,0>
 00001005		     1		.data		
 00001005 2D 2D 2D 2D 2D     1		??0096 BYTE "---------------------------------------: ",0ah,0dh,0,0	
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 3A
	   20 0A 0D 00 00
 000016F3		     1		.code
 000016F3  52		     1		push	edx
 000016F4  BA 00001005 R     1		mov	edx,OFFSET ??0096
 000016F9  E8 00000000 E     1		call	WriteString
 000016FE  5A		     1		pop	edx
 000016FF  E8 00000000 E		call readint
					.if eax==1
 00001704  83 F8 01	   *	    cmp    eax, 001h
 00001707  75 04	   *	    jne    @C00A0
 00001709  EB 07				jmp case1
					.else
 0000170B  EB 05	   *	    jmp    @C00A2
 0000170D		   *@C00A0:
 0000170D  E9 00000143				jmp case2
					.endif
 00001712		   *@C00A2:
 00001712				case1:
						mwrite<"Enter the elements of Matrix_01",0ah,0dh,0>
 00001032		     1		.data		
 00001032 45 6E 74 65 72     1		??0097 BYTE "Enter the elements of Matrix_01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 5F 30
	   31 0A 0D 00 00
 00001712		     1		.code
 00001712  52		     1		push	edx
 00001713  BA 00001032 R     1		mov	edx,OFFSET ??0097
 00001718  E8 00000000 E     1		call	WriteString
 0000171D  5A		     1		pop	edx
 0000171E  BE 00000000				mov esi,0
 00001723  B9 00000004				mov ecx,4
 00001728					L11:
 00001728  E8 00000000 E				call readint
 0000172D  89 86 00000234 R				mov arr[esi],eax
 00001733  83 C6 04					add esi,type arr
 00001736  E2 F0				loop L11

						mwrite<"Enter the elements of Matrix_02",0ah,0dh,0>
 00001055		     1		.data		
 00001055 45 6E 74 65 72     1		??0098 BYTE "Enter the elements of Matrix_02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 5F 30
	   32 0A 0D 00 00
 00001738		     1		.code
 00001738  52		     1		push	edx
 00001739  BA 00001055 R     1		mov	edx,OFFSET ??0098
 0000173E  E8 00000000 E     1		call	WriteString
 00001743  5A		     1		pop	edx
 00001744  BE 00000000				mov esi,0
 00001749  B9 00000004				mov ecx,4
 0000174E					L12:
 0000174E  E8 00000000 E				call readint
 00001753  89 86 00000258 R				mov arr1[esi],eax
 00001759  83 C6 04					add esi,type arr1
 0000175C  E2 F0				loop L12

 0000175E  BE 00000000				mov esi,0
 00001763  8B 86 00000234 R			mov eax,arr[esi]
 00001769  8B 9E 00000258 R			mov ebx,arr1[esi]
 0000176F  F7 E3				mul ebx
 00001771  A3 00000000 R			mov var1,eax
 00001776  8B 86 00000238 R			mov eax,arr[esi+4]
 0000177C  8B 9E 00000260 R			mov ebx,arr1[esi+8]
 00001782  F7 E3				mul ebx
 00001784  03 05 00000000 R			add eax,var1
 0000178A  50					push eax

 0000178B  8B 86 00000234 R			mov eax,arr[esi]
 00001791  8B 9E 0000025C R			mov ebx,arr1[esi+4]
 00001797  F7 E3				mul ebx
 00001799  A3 00000000 R			mov var1,eax
 0000179E  8B 86 00000238 R			mov eax,arr[esi+4]
 000017A4  8B 9E 00000264 R			mov ebx,arr1[esi+12]
 000017AA  F7 E3				mul ebx
 000017AC  03 05 00000000 R			add eax,var1
 000017B2  50					push eax

 000017B3  8B 86 0000023C R			mov eax,arr[esi+8]
 000017B9  8B 9E 00000258 R			mov ebx,arr1[esi]
 000017BF  F7 E3				mul ebx
 000017C1  A3 00000000 R			mov var1,eax
 000017C6  8B 86 00000240 R			mov eax,arr[esi+12]
 000017CC  8B 9E 00000260 R			mov ebx,arr1[esi+8]
 000017D2  F7 E3				mul ebx
 000017D4  03 05 00000000 R			add eax,var1
 000017DA  50					push eax

 000017DB  8B 86 0000023C R			mov eax,arr[esi+8]
 000017E1  8B 9E 0000025C R			mov ebx,arr1[esi+4]
 000017E7  F7 E3				mul ebx
 000017E9  A3 00000000 R			mov var1,eax
 000017EE  8B 86 00000240 R			mov eax,arr[esi+12]
 000017F4  8B 9E 00000264 R			mov ebx,arr1[esi+12]
 000017FA  F7 E3				mul ebx
 000017FC  03 05 00000000 R			add eax,var1
 00001802  50					push eax

 00001803  BE 00000000				mov esi,0
 00001808  B9 00000004				mov ecx,4
 0000180D					Lpop:
 0000180D  58						pop eax
 0000180E  89 86 00000234 R				mov arr[esi],eax
 00001814  83 C6 04					add esi,type arr
 00001817  E2 F4				loop Lpop

 00001819  BE 0000000C				mov esi,12
 0000181E  B9 00000004				mov ecx,4
 00001823					Lprint:
 00001823  8B 86 00000234 R				mov eax,arr[esi]
							.if ecx==2
 00001829  83 F9 02	   *	    cmp    ecx, 002h
 0000182C  75 0C	   *	    jne    @C00A3
							mwrite<"	",0ah,0dh,0>
 00001078		     1		.data		
 00001078 09 0A 0D 00 00     1		??0099 BYTE "	",0ah,0dh,0,0	
 0000182E		     1		.code
 0000182E  52		     1		push	edx
 0000182F  BA 00001078 R     1		mov	edx,OFFSET ??0099
 00001834  E8 00000000 E     1		call	WriteString
 00001839  5A		     1		pop	edx
							.endif
 0000183A		   *@C00A3:
							mwrite<"	",0>
 0000107D		     1		.data		
 0000107D 09 00 00	     1		??009A BYTE "	",0,0	
 0000183A		     1		.code
 0000183A  52		     1		push	edx
 0000183B  BA 0000107D R     1		mov	edx,OFFSET ??009A
 00001840  E8 00000000 E     1		call	WriteString
 00001845  5A		     1		pop	edx
 00001846  E8 00000000 E				call writeint
 0000184B  83 EE 04					sub esi,type arr
 0000184E  E2 D3				loop Lprint
 00001850  E9 00000314				jmp LExit
 00001855					case2:
						mwrite<"Enter the elements of Matrix_01",0ah,0dh,0>
 00001080		     1		.data		
 00001080 45 6E 74 65 72     1		??009B BYTE "Enter the elements of Matrix_01",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 5F 30
	   31 0A 0D 00 00
 00001855		     1		.code
 00001855  52		     1		push	edx
 00001856  BA 00001080 R     1		mov	edx,OFFSET ??009B
 0000185B  E8 00000000 E     1		call	WriteString
 00001860  5A		     1		pop	edx
 00001861  BE 00000000				mov esi,0
 00001866  B9 00000009				mov ecx,9
 0000186B					L21:
 0000186B  E8 00000000 E				call readint
 00001870  89 86 00000234 R				mov arr[esi],eax
 00001876  83 C6 04					add esi,type arr
 00001879  E2 F0				loop L21

						mwrite<"Enter the elements of Matrix_02",0ah,0dh,0>

 000010A3		     1		.data		
 000010A3 45 6E 74 65 72     1		??009C BYTE "Enter the elements of Matrix_02",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 5F 30
	   32 0A 0D 00 00
 0000187B		     1		.code
 0000187B  52		     1		push	edx
 0000187C  BA 000010A3 R     1		mov	edx,OFFSET ??009C
 00001881  E8 00000000 E     1		call	WriteString
 00001886  5A		     1		pop	edx
 00001887  BE 00000000				mov esi,0
 0000188C  B9 00000009				mov ecx,9
 00001891					L22:
 00001891  E8 00000000 E				call readint
 00001896  89 86 00000258 R				mov arr1[esi],eax
 0000189C  83 C6 04					add esi,type arr1
 0000189F  E2 F0				loop L22

 000018A1  BE 00000000				mov esi,0
 000018A6  8B 86 00000234 R			mov eax,arr[esi]
 000018AC  8B 9E 00000258 R			mov ebx,arr1[esi]
 000018B2  F7 E3				mul ebx
 000018B4  A3 00000000 R			mov var1,eax
 000018B9  8B 86 00000238 R			mov eax,arr[esi+4]
 000018BF  8B 9E 00000264 R			mov ebx,arr1[esi+12]
 000018C5  F7 E3				mul ebx
 000018C7  A3 00000004 R			mov var2,eax
 000018CC  8B 86 0000023C R			mov eax,arr[esi+8]
 000018D2  8B 9E 00000270 R			mov ebx,arr1[esi+24]
 000018D8  F7 E3				mul ebx
 000018DA  03 05 00000000 R			add eax,var1
 000018E0  03 05 00000004 R			add eax,var2
 000018E6  50					push eax

 000018E7  BE 00000000				mov esi,0
 000018EC  8B 86 00000234 R			mov eax,arr[esi]
 000018F2  8B 9E 0000025C R			mov ebx,arr1[esi+4]
 000018F8  F7 E3				mul ebx
 000018FA  A3 00000000 R			mov var1,eax
 000018FF  8B 86 00000238 R			mov eax,arr[esi+4]
 00001905  8B 9E 00000268 R			mov ebx,arr1[esi+16]
 0000190B  F7 E3				mul ebx
 0000190D  A3 00000004 R			mov var2,eax
 00001912  8B 86 0000023C R			mov eax,arr[esi+8]
 00001918  8B 9E 00000274 R			mov ebx,arr1[esi+28]
 0000191E  F7 E3				mul ebx
 00001920  03 05 00000000 R			add eax,var1
 00001926  03 05 00000004 R			add eax,var2
 0000192C  50					push eax

 0000192D  BE 00000000				mov esi,0
 00001932  8B 86 00000234 R			mov eax,arr[esi]
 00001938  8B 9E 00000260 R			mov ebx,arr1[esi+8]
 0000193E  F7 E3				mul ebx
 00001940  A3 00000000 R			mov var1,eax
 00001945  8B 86 00000238 R			mov eax,arr[esi+4]
 0000194B  8B 9E 0000026C R			mov ebx,arr1[esi+20]
 00001951  F7 E3				mul ebx
 00001953  A3 00000004 R			mov var2,eax
 00001958  8B 86 0000023C R			mov eax,arr[esi+8]
 0000195E  8B 9E 00000278 R			mov ebx,arr1[esi+32]
 00001964  F7 E3				mul ebx
 00001966  03 05 00000000 R			add eax,var1
 0000196C  03 05 00000004 R			add eax,var2
 00001972  50					push eax
						
 00001973  BE 00000000				mov esi,0
 00001978  8B 86 00000240 R			mov eax,arr[esi+12]
 0000197E  8B 9E 00000258 R			mov ebx,arr1[esi]
 00001984  F7 E3				mul ebx
 00001986  A3 00000000 R			mov var1,eax
 0000198B  8B 86 00000244 R			mov eax,arr[esi+16]
 00001991  8B 9E 00000264 R			mov ebx,arr1[esi+12]
 00001997  F7 E3				mul ebx
 00001999  A3 00000004 R			mov var2,eax
 0000199E  8B 86 00000248 R			mov eax,arr[esi+20]
 000019A4  8B 9E 00000270 R			mov ebx,arr1[esi+24]
 000019AA  F7 E3				mul ebx
 000019AC  03 05 00000000 R			add eax,var1
 000019B2  03 05 00000004 R			add eax,var2
 000019B8  50					push eax

 000019B9  BE 00000000				mov esi,0
 000019BE  8B 86 00000240 R			mov eax,arr[esi+12]
 000019C4  8B 9E 0000025C R			mov ebx,arr1[esi+4]
 000019CA  F7 E3				mul ebx
 000019CC  A3 00000000 R			mov var1,eax
 000019D1  8B 86 00000244 R			mov eax,arr[esi+16]
 000019D7  8B 9E 00000268 R			mov ebx,arr1[esi+16]
 000019DD  F7 E3				mul ebx
 000019DF  A3 00000004 R			mov var2,eax
 000019E4  8B 86 00000248 R			mov eax,arr[esi+20]
 000019EA  8B 9E 00000274 R			mov ebx,arr1[esi+28]
 000019F0  F7 E3				mul ebx
 000019F2  03 05 00000000 R			add eax,var1
 000019F8  03 05 00000004 R			add eax,var2
 000019FE  50					push eax

 000019FF  BE 00000000				mov esi,0
 00001A04  8B 86 00000240 R			mov eax,arr[esi+12]
 00001A0A  8B 9E 00000260 R			mov ebx,arr1[esi+8]
 00001A10  F7 E3				mul ebx
 00001A12  A3 00000000 R			mov var1,eax
 00001A17  8B 86 00000244 R			mov eax,arr[esi+16]
 00001A1D  8B 9E 0000026C R			mov ebx,arr1[esi+20]
 00001A23  F7 E3				mul ebx
 00001A25  A3 00000004 R			mov var2,eax
 00001A2A  8B 86 00000248 R			mov eax,arr[esi+20]
 00001A30  8B 9E 00000278 R			mov ebx,arr1[esi+32]
 00001A36  F7 E3				mul ebx
 00001A38  03 05 00000000 R			add eax,var1
 00001A3E  03 05 00000004 R			add eax,var2
 00001A44  50					push eax
						
 00001A45  BE 00000000				mov esi,0
 00001A4A  8B 86 0000024C R			mov eax,arr[esi+24]
 00001A50  8B 9E 00000258 R			mov ebx,arr1[esi]
 00001A56  F7 E3				mul ebx
 00001A58  A3 00000000 R			mov var1,eax
 00001A5D  8B 86 00000250 R			mov eax,arr[esi+28]
 00001A63  8B 9E 00000264 R			mov ebx,arr1[esi+12]
 00001A69  F7 E3				mul ebx
 00001A6B  A3 00000004 R			mov var2,eax
 00001A70  8B 86 00000254 R			mov eax,arr[esi+32]
 00001A76  8B 9E 00000270 R			mov ebx,arr1[esi+24]
 00001A7C  F7 E3				mul ebx
 00001A7E  03 05 00000000 R			add eax,var1
 00001A84  03 05 00000004 R			add eax,var2
 00001A8A  50					push eax

 00001A8B  BE 00000000				mov esi,0
 00001A90  8B 86 0000024C R			mov eax,arr[esi+24]
 00001A96  8B 9E 0000025C R			mov ebx,arr1[esi+4]
 00001A9C  F7 E3				mul ebx
 00001A9E  A3 00000000 R			mov var1,eax
 00001AA3  8B 86 00000250 R			mov eax,arr[esi+28]
 00001AA9  8B 9E 00000268 R			mov ebx,arr1[esi+16]
 00001AAF  F7 E3				mul ebx
 00001AB1  A3 00000004 R			mov var2,eax
 00001AB6  8B 86 00000254 R			mov eax,arr[esi+32]
 00001ABC  8B 9E 00000274 R			mov ebx,arr1[esi+28]
 00001AC2  F7 E3				mul ebx
 00001AC4  03 05 00000000 R			add eax,var1
 00001ACA  03 05 00000004 R			add eax,var2
 00001AD0  50					push eax

 00001AD1  BE 00000000				mov esi,0
 00001AD6  8B 86 0000024C R			mov eax,arr[esi+24]
 00001ADC  8B 9E 00000260 R			mov ebx,arr1[esi+8]
 00001AE2  F7 E3				mul ebx
 00001AE4  A3 00000000 R			mov var1,eax
 00001AE9  8B 86 00000250 R			mov eax,arr[esi+28]
 00001AEF  8B 9E 0000026C R			mov ebx,arr1[esi+20]
 00001AF5  F7 E3				mul ebx
 00001AF7  A3 00000004 R			mov var2,eax
 00001AFC  8B 86 00000254 R			mov eax,arr[esi+32]
 00001B02  8B 9E 00000278 R			mov ebx,arr1[esi+32]
 00001B08  F7 E3				mul ebx
 00001B0A  03 05 00000000 R			add eax,var1
 00001B10  03 05 00000004 R			add eax,var2
 00001B16  50					push eax

 00001B17  BE 00000000				mov esi,0
 00001B1C  B9 00000009				mov ecx,9
 00001B21					Lpop2:
 00001B21  58						pop eax
 00001B22  89 86 00000234 R				mov arr[esi],eax
 00001B28  83 C6 04					add esi,type arr
 00001B2B  E2 F4				loop Lpop2

 00001B2D  BE 00000020				mov esi,32
 00001B32  B9 00000009				mov ecx,9
 00001B37					Lprint2:
 00001B37  8B 86 00000234 R				mov eax,arr[esi]
							.if ecx==6 || ecx==3
 00001B3D  83 F9 06	   *	    cmp    ecx, 006h
 00001B40  74 05	   *	    je	@C00A6
 00001B42  83 F9 03	   *	    cmp    ecx, 003h
 00001B45  75 0C	   *	    jne    @C00A5
 00001B47		   *@C00A6:
							mwrite<"	",0ah,0dh,0>
 000010C6		     1		.data		
 000010C6 09 0A 0D 00 00     1		??009D BYTE "	",0ah,0dh,0,0	
 00001B47		     1		.code
 00001B47  52		     1		push	edx
 00001B48  BA 000010C6 R     1		mov	edx,OFFSET ??009D
 00001B4D  E8 00000000 E     1		call	WriteString
 00001B52  5A		     1		pop	edx
							.endif
 00001B53		   *@C00A5:
							mwrite<"	",0>
 000010CB		     1		.data		
 000010CB 09 00 00	     1		??009E BYTE "	",0,0	
 00001B53		     1		.code
 00001B53  52		     1		push	edx
 00001B54  BA 000010CB R     1		mov	edx,OFFSET ??009E
 00001B59  E8 00000000 E     1		call	WriteString
 00001B5E  5A		     1		pop	edx
 00001B5F  E8 00000000 E				call writeint
 00001B64  83 EE 04					sub esi,type arr
 00001B67  E2 CE				loop Lprint2

 00001B69					LExit:
 00001B69  C3					ret
 00001B6A			Multiplication endp

				;procedure for the inverse of a given matrix
 00001B6A			Inverse proc
 00001B6A  E8 00000000 E		call crlf
					mwrite<"		1.For 2X2 Matrix ",0ah,0dh,0>
 000010CE		     1		.data		
 000010CE 09 09 31 2E 46     1		??009F BYTE "		1.For 2X2 Matrix ",0ah,0dh,0,0	
	   6F 72 20 32 58
	   32 20 4D 61 74
	   72 69 78 20 0A
	   0D 00 00
 00001B6F		     1		.code
 00001B6F  52		     1		push	edx
 00001B70  BA 000010CE R     1		mov	edx,OFFSET ??009F
 00001B75  E8 00000000 E     1		call	WriteString
 00001B7A  5A		     1		pop	edx
					mwrite<"		2.For 3X3 Matrix ",0ah,0dh,0>
 000010E5		     1		.data		
 000010E5 09 09 32 2E 46     1		??00A0 BYTE "		2.For 3X3 Matrix ",0ah,0dh,0,0	
	   6F 72 20 33 58
	   33 20 4D 61 74
	   72 69 78 20 0A
	   0D 00 00
 00001B7B		     1		.code
 00001B7B  52		     1		push	edx
 00001B7C  BA 000010E5 R     1		mov	edx,OFFSET ??00A0
 00001B81  E8 00000000 E     1		call	WriteString
 00001B86  5A		     1		pop	edx
					mwrite<"		Enter your Choice: ",0ah,0dh,0>
 000010FC		     1		.data		
 000010FC 09 09 45 6E 74     1		??00A1 BYTE "		Enter your Choice: ",0ah,0dh,0,0	
	   65 72 20 79 6F
	   75 72 20 43 68
	   6F 69 63 65 3A
	   20 0A 0D 00 00
 00001B87		     1		.code
 00001B87  52		     1		push	edx
 00001B88  BA 000010FC R     1		mov	edx,OFFSET ??00A1
 00001B8D  E8 00000000 E     1		call	WriteString
 00001B92  5A		     1		pop	edx
					mwrite<"---------------------------------------: ",0>
 00001115		     1		.data		
 00001115 2D 2D 2D 2D 2D     1		??00A2 BYTE "---------------------------------------: ",0,0	
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 3A
	   20 00 00
 00001B93		     1		.code
 00001B93  52		     1		push	edx
 00001B94  BA 00001115 R     1		mov	edx,OFFSET ??00A2
 00001B99  E8 00000000 E     1		call	WriteString
 00001B9E  5A		     1		pop	edx
 00001B9F  E8 00000000 E		call readint
					.if eax==1
 00001BA4  83 F8 01	   *	    cmp    eax, 001h
 00001BA7  75 04	   *	    jne    @C00A8
 00001BA9  EB 07				jmp case1
					.else
 00001BAB  EB 05	   *	    jmp    @C00AA
 00001BAD		   *@C00A8:
 00001BAD  E9 000000EF				jmp case2
					.endif
 00001BB2		   *@C00AA:
 00001BB2				case1:

						mwrite<"Enter the elements of Matrix",0ah,0dh,0>
 00001140		     1		.data		
 00001140 45 6E 74 65 72     1		??00A3 BYTE "Enter the elements of Matrix",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 0A 0D
	   00 00
 00001BB2		     1		.code
 00001BB2  52		     1		push	edx
 00001BB3  BA 00001140 R     1		mov	edx,OFFSET ??00A3
 00001BB8  E8 00000000 E     1		call	WriteString
 00001BBD  5A		     1		pop	edx
 00001BBE  BE 00000000				mov esi,0
 00001BC3  B9 00000004				mov ecx,4
 00001BC8					L11:
 00001BC8  E8 00000000 E				call readint
 00001BCD  89 86 00000234 R				mov arr[esi],eax
 00001BD3  83 C6 04					add esi,type arr
 00001BD6  E2 F0				loop L11

 00001BD8  BE 00000000				mov esi,0
 00001BDD  8B 86 00000234 R			mov eax,arr[esi]
 00001BE3  8B 9E 00000240 R			mov ebx,arr[esi+12]
 00001BE9  F7 E3				mul ebx
 00001BEB  50					push eax
 00001BEC  8B 86 00000238 R			mov eax,arr[esi+4]
 00001BF2  8B 9E 0000023C R			mov ebx,arr[esi+8]
 00001BF8  F7 E3				mul ebx
 00001BFA  A3 00000000 R			mov var1,eax
 00001BFF  58					pop eax
 00001C00  2B 05 00000000 R			sub eax,var1
 00001C06  A3 00000000 R			mov var1,eax

 00001C0B  E8 00000000 E			call writeint
						.if eax==0
 00001C10  0B C0	   *	    or	eax, eax
 00001C12  75 13	   *	    jne    @C00AB
							mwrite<0ah,0dh,"As it is Singular Matrix So,solution Does not Exit",0ah,0dh,0>
 00001160		     1		.data		
 00001160 0A 0D 41 73 20     1		??00A4 BYTE 0ah,0dh,"As it is Singular Matrix So,solution Does not Exit",0ah,0dh,0,0	
	   69 74 20 69 73
	   20 53 69 6E 67
	   75 6C 61 72 20
	   4D 61 74 72 69
	   78 20 53 6F 2C
	   73 6F 6C 75 74
	   69 6F 6E 20 44
	   6F 65 73 20 6E
	   6F 74 20 45 78
	   69 74 0A 0D 00
	   00
 00001C14		     1		.code
 00001C14  52		     1		push	edx
 00001C15  BA 00001160 R     1		mov	edx,OFFSET ??00A4
 00001C1A  E8 00000000 E     1		call	WriteString
 00001C1F  5A		     1		pop	edx
 00001C20  E9 00000420					jmp LExit
						.else
 00001C25  EB 75	   *	    jmp    @C00AD
 00001C27		   *@C00AB:
 00001C27  BE 00000000					mov esi,0
 00001C2C  8B 86 00000234 R				mov eax,arr[esi]
 00001C32  87 86 00000240 R				xchg eax,arr[esi+12]
 00001C38  89 86 00000234 R				mov arr[esi],eax
 00001C3E  8B 86 00000238 R				mov eax,arr[esi+4]
 00001C44  F7 D8					neg eax
 00001C46  89 86 00000238 R				mov arr[esi+4],eax

 00001C4C  8B 86 0000023C R				mov eax,arr[esi+8]
 00001C52  F7 D8					neg eax
 00001C54  89 86 0000023C R				mov arr[esi+8],eax

 00001C5A  BE 00000000					mov esi,0
 00001C5F  B9 00000004					mov ecx,4
 00001C64						L13:
 00001C64  8B 86 00000234 R				mov eax,arr[esi]
 00001C6A  BA 00000000					mov edx,0
 00001C6F  F7 35 00000000 R				div var1
							.if ecx==2
 00001C75  83 F9 02	   *	    cmp    ecx, 002h
 00001C78  75 0C	   *	    jne    @C00AE
							mwrite<" ",0ah,0dh,0>
 00001198		     1		.data		
 00001198 20 0A 0D 00 00     1		??00A5 BYTE " ",0ah,0dh,0,0	
 00001C7A		     1		.code
 00001C7A  52		     1		push	edx
 00001C7B  BA 00001198 R     1		mov	edx,OFFSET ??00A5
 00001C80  E8 00000000 E     1		call	WriteString
 00001C85  5A		     1		pop	edx
							.endif
							mwrite<"	",0>
 00001C86 0000119D	     1		.data		
 0000119D 09 00 00	     1		??00A6 BYTE "	",0,0	
 00001C86		     1		.code
 00001C86  52		     1		push	edx
 00001C87  BA 0000119D R     1		mov	edx,OFFSET ??00A6
 00001C8C  E8 00000000 E     1		call	WriteString
 00001C91  5A		     1		pop	edx
 00001C92  E8 00000000 E				call writeint
 00001C97  83 C6 04					add esi, type arr
 00001C9A  E2 C8					loop L13
						.endif
 00001C9C		   *@C00AD:
 00001C9C  E9 000003A4			jmp LExit
 00001CA1				case2:

					mwrite<"Enter the elements of Matrix",0ah,0dh,0>
 000011A0		     1		.data		
 000011A0 45 6E 74 65 72     1		??00A7 BYTE "Enter the elements of Matrix",0ah,0dh,0,0	
	   20 74 68 65 20
	   65 6C 65 6D 65
	   6E 74 73 20 6F
	   66 20 4D 61 74
	   72 69 78 0A 0D
	   00 00
 00001CA1		     1		.code
 00001CA1  52		     1		push	edx
 00001CA2  BA 000011A0 R     1		mov	edx,OFFSET ??00A7
 00001CA7  E8 00000000 E     1		call	WriteString
 00001CAC  5A		     1		pop	edx
 00001CAD  BE 00000000				mov esi,0
 00001CB2  B9 00000009				mov ecx,9
 00001CB7					L21:
 00001CB7  E8 00000000 E				call readint
 00001CBC  89 86 00000234 R				mov arr[esi],eax
 00001CC2  83 C6 04					add esi,type arr
 00001CC5  E2 F0				loop L21

 00001CC7  BE 00000000				mov esi,0
 00001CCC  8B 86 00000234 R			mov eax,arr[esi]
 00001CD2  A3 00000000 R			mov var1,eax
 00001CD7  8B 86 00000244 R			mov eax,arr[esi+16]
 00001CDD  8B 9E 00000254 R			mov ebx,arr[esi+32]
 00001CE3  F7 E3				mul ebx
 00001CE5  A3 00000004 R			mov var2,eax
 00001CEA  8B 86 00000248 R			mov eax,arr[esi+20]
 00001CF0  8B 9E 00000250 R			mov ebx,arr[esi+28]
 00001CF6  F7 E3				mul ebx
 00001CF8  A3 00000008 R			mov var3,eax
 00001CFD  A1 00000004 R			mov eax,var2
 00001D02  2B 05 00000008 R			sub eax,var3
 00001D08  F7 25 00000000 R			mul var1
 00001D0E  50					push eax

 00001D0F  8B 86 00000238 R			mov eax,arr[esi+4]
 00001D15  F7 D8				neg eax
 00001D17  A3 00000000 R			mov var1,eax
 00001D1C  8B 86 00000240 R			mov eax,arr[esi+12]
 00001D22  8B 9E 00000254 R			mov ebx,arr[esi+32]
 00001D28  F7 E3				mul ebx
 00001D2A  A3 00000004 R			mov var2,eax
 00001D2F  8B 86 00000248 R			mov eax,arr[esi+20]
 00001D35  8B 9E 0000024C R			mov ebx,arr[esi+24]
 00001D3B  F7 E3				mul ebx
 00001D3D  A3 00000008 R			mov var3,eax
 00001D42  A1 00000004 R			mov eax,var2
 00001D47  2B 05 00000008 R			sub eax,var3
 00001D4D  F7 25 00000000 R			mul var1
 00001D53  50					push eax

 00001D54  8B 86 0000023C R			mov eax,arr[esi+8]
 00001D5A  A3 00000000 R			mov var1,eax
 00001D5F  8B 86 00000240 R			mov eax,arr[esi+12]
 00001D65  8B 9E 00000250 R			mov ebx,arr[esi+28]
 00001D6B  F7 E3				mul ebx
 00001D6D  A3 00000004 R			mov var2,eax
 00001D72  8B 86 00000244 R			mov eax,arr[esi+16]
 00001D78  8B 9E 0000024C R			mov ebx,arr[esi+24]
 00001D7E  F7 E3				mul ebx
 00001D80  A3 00000008 R			mov var3,eax
 00001D85  A1 00000004 R			mov eax,var2
 00001D8A  2B 05 00000008 R			sub eax,var3
 00001D90  F7 25 00000000 R			mul var1
 00001D96  A3 00000000 R			mov var1,eax
 00001D9B  58					pop eax
 00001D9C  A3 00000004 R			mov var2,eax
 00001DA1  58					pop eax
 00001DA2  03 05 00000004 R			add eax,var2
 00001DA8  03 05 00000000 R			add eax,var1
 00001DAE  E8 00000000 E			call writeint

						.if eax==0
 00001DB3  0B C0	   *	    or	eax, eax
 00001DB5  75 16	   *	    jne    @C00B0
							mwrite<0ah,0dh,"As it is Singular Matrix So,solution Does not Exit",0ah,0dh,0>
 000011C0		     1		.data		
 000011C0 0A 0D 41 73 20     1		??00A8 BYTE 0ah,0dh,"As it is Singular Matrix So,solution Does not Exit",0ah,0dh,0,0	
	   69 74 20 69 73
	   20 53 69 6E 67
	   75 6C 61 72 20
	   4D 61 74 72 69
	   78 20 53 6F 2C
	   73 6F 6C 75 74
	   69 6F 6E 20 44
	   6F 65 73 20 6E
	   6F 74 20 45 78
	   69 74 0A 0D 00
	   00
 00001DB7		     1		.code
 00001DB7  52		     1		push	edx
 00001DB8  BA 000011C0 R     1		mov	edx,OFFSET ??00A8
 00001DBD  E8 00000000 E     1		call	WriteString
 00001DC2  5A		     1		pop	edx
 00001DC3  E9 0000027D					jmp LExit
						.else
 00001DC8  E9 00000278	   *	    jmp    @C00B2
 00001DCD		   *@C00B0:
 00001DCD  50						push eax

 00001DCE  BE 00000000					mov esi,0
 00001DD3  8B 86 00000244 R				mov eax,arr[esi+16]
 00001DD9  8B 9E 00000254 R				mov ebx,arr[esi+32]
 00001DDF  F7 E3					mul ebx
 00001DE1  A3 00000000 R				mov var1,eax
 00001DE6  8B 86 00000248 R				mov eax,arr[esi+20]
 00001DEC  8B 9E 00000250 R				mov ebx,arr[esi+28]
 00001DF2  F7 E3					mul ebx
 00001DF4  A3 00000004 R				mov var2,eax
 00001DF9  A1 00000000 R				mov eax,var1
 00001DFE  2B 05 00000004 R				sub eax,var2
 00001E04  50						push eax

							;calculating 2nd Cofector
 00001E05  8B 86 00000240 R				mov eax,arr[esi+12]
 00001E0B  8B 9E 00000254 R				mov ebx,arr[esi+32]
 00001E11  F7 E3					mul ebx
 00001E13  A3 00000000 R				mov var1,eax
 00001E18  8B 86 00000248 R				mov eax,arr[esi+20]
 00001E1E  8B 9E 0000024C R				mov ebx,arr[esi+24]
 00001E24  F7 E3					mul ebx
 00001E26  A3 00000004 R				mov var2,eax
 00001E2B  A1 00000000 R				mov eax,var1
 00001E30  2B 05 00000004 R				sub eax,var2
 00001E36  F7 D8					neg eax
 00001E38  50						push eax

							;calculating 3rd Cofector
 00001E39  8B 86 00000240 R				mov eax,arr[esi+12]
 00001E3F  8B 9E 00000250 R				mov ebx,arr[esi+28]
 00001E45  F7 E3					mul ebx
 00001E47  A3 00000000 R				mov var1,eax
 00001E4C  8B 86 00000244 R				mov eax,arr[esi+16]
 00001E52  8B 9E 0000024C R				mov ebx,arr[esi+24]
 00001E58  F7 E3					mul ebx
 00001E5A  A3 00000004 R				mov var2,eax
 00001E5F  A1 00000000 R				mov eax,var1
 00001E64  2B 05 00000004 R				sub eax,var2
 00001E6A  50						push eax

							;calculating 4rth Cofector
 00001E6B  8B 86 00000238 R				mov eax,arr[esi+4]
 00001E71  8B 9E 00000254 R				mov ebx,arr[esi+32]
 00001E77  F7 E3					mul ebx
 00001E79  A3 00000000 R				mov var1,eax
 00001E7E  8B 86 0000023C R				mov eax,arr[esi+8]
					
 00001E84  8B 9E 00000250 R				mov ebx,arr[esi+28]
 00001E8A  F7 E3					mul ebx
 00001E8C  A3 00000004 R				mov var2,eax
 00001E91  A1 00000000 R				mov eax,var1
 00001E96  2B 05 00000004 R				sub eax,var2
 00001E9C  F7 D8					neg eax
 00001E9E  50						push eax

							;calculating 5rth Cofector
 00001E9F  8B 86 00000234 R				mov eax,arr[esi]
 00001EA5  8B 9E 00000254 R				mov ebx,arr[esi+32]
 00001EAB  F7 E3					mul ebx
 00001EAD  A3 00000000 R				mov var1,eax
 00001EB2  8B 86 0000023C R				mov eax,arr[esi+8]
 00001EB8  8B 9E 0000024C R				mov ebx,arr[esi+24]
 00001EBE  F7 E3					mul ebx
 00001EC0  A3 00000004 R				mov var2,eax
 00001EC5  A1 00000000 R				mov eax,var1
 00001ECA  2B 05 00000004 R				sub eax,var2
 00001ED0  50						push eax

							;calculating 6th Cofector
 00001ED1  8B 86 00000234 R				mov eax,arr[esi]
 00001ED7  8B 9E 00000250 R				mov ebx,arr[esi+28]
 00001EDD  F7 E3					mul ebx
 00001EDF  A3 00000000 R				mov var1,eax
 00001EE4  8B 86 00000238 R				mov eax,arr[esi+4]
 00001EEA  8B 9E 0000024C R				mov ebx,arr[esi+24]
 00001EF0  F7 E3					mul ebx
 00001EF2  A3 00000004 R				mov var2,eax
 00001EF7  A1 00000000 R				mov eax,var1
 00001EFC  2B 05 00000004 R				sub eax,var2
 00001F02  F7 D8					neg eax
 00001F04  50						push eax

							;calculating 7th Cofector
 00001F05  8B 86 00000238 R				mov eax,arr[esi+4]
 00001F0B  8B 9E 00000248 R				mov ebx,arr[esi+20]
 00001F11  F7 E3					mul ebx
 00001F13  A3 00000000 R				mov var1,eax
 00001F18  8B 86 0000023C R				mov eax,arr[esi+8]
 00001F1E  8B 9E 00000244 R				mov ebx,arr[esi+16]
 00001F24  F7 E3					mul ebx
 00001F26  A3 00000004 R				mov var2,eax
 00001F2B  A1 00000000 R				mov eax,var1
 00001F30  2B 05 00000004 R				sub eax,var2
 00001F36  50						push eax

							;calculating 8th Cofector

 00001F37  8B 86 00000234 R				mov eax,arr[esi]
 00001F3D  8B 9E 00000248 R				mov ebx,arr[esi+20]
 00001F43  F7 E3					mul ebx
 00001F45  A3 00000000 R				mov var1,eax
 00001F4A  8B 86 0000023C R				mov eax,arr[esi+8]
 00001F50  8B 9E 00000240 R				mov ebx,arr[esi+12]
 00001F56  F7 E3					mul ebx
 00001F58  A3 00000004 R				mov var2,eax
 00001F5D  A1 00000000 R				mov eax,var1
 00001F62  2B 05 00000004 R				sub eax,var2
 00001F68  F7 D8					neg eax
 00001F6A  50						push eax

							;calculating 9th Cofector
 00001F6B  8B 86 00000234 R				mov eax,arr[esi]
 00001F71  8B 9E 00000244 R				mov ebx,arr[esi+16]
 00001F77  F7 E3					mul ebx
 00001F79  A3 00000000 R				mov var1,eax
 00001F7E  8B 86 00000238 R				mov eax,arr[esi+4]
 00001F84  8B 9E 00000240 R				mov ebx,arr[esi+12]
 00001F8A  F7 E3					mul ebx
 00001F8C  A3 00000004 R				mov var2,eax
 00001F91  A1 00000000 R				mov eax,var1
 00001F96  2B 05 00000004 R				sub eax,var2
 00001F9C  50						push eax

 00001F9D  BE 00000000					mov esi,0
 00001FA2  B9 00000009					mov ecx,9
 00001FA7						Lpop:
 00001FA7  58							pop eax
 00001FA8  89 86 00000234 R					mov arr[esi],eax
 00001FAE  83 C6 04						add esi,type arr
 00001FB1  E2 F4					loop Lpop

 00001FB3  BE 00000000					mov esi,0
 00001FB8  8B 86 00000234 R				mov eax,arr[esi]
 00001FBE  87 86 00000254 R				xchg eax,arr[esi+32]
 00001FC4  89 86 00000234 R				mov arr[esi],eax
 00001FCA  BE 00000000					mov esi,0
 00001FCF  8B 86 00000238 R				mov eax,arr[esi+4]
 00001FD5  87 86 00000248 R				xchg eax,arr[esi+20]
 00001FDB  89 86 00000238 R				mov arr[esi+4],eax
 00001FE1  BE 00000000					mov esi,0
 00001FE6  8B 86 00000240 R				mov eax,arr[esi+12]
 00001FEC  87 86 00000250 R				xchg eax,arr[esi+28]
 00001FF2  89 86 00000240 R				mov arr[esi+12],eax

 00001FF8  8F 05 00000000 R				pop var1

 00001FFE  BE 00000000					mov esi,0
 00002003  B9 00000009					mov ecx,9
 00002008						Lprint:
 00002008  8B 86 00000234 R					mov eax,arr[esi]
 0000200E  BA 00000000						mov edx,0
 00002013  F7 35 00000000 R					div var1
								.if ecx==6 || ecx==3
 00002019  83 F9 06	   *	    cmp    ecx, 006h
 0000201C  74 05	   *	    je	@C00B4
 0000201E  83 F9 03	   *	    cmp    ecx, 003h
 00002021  75 0C	   *	    jne    @C00B3
 00002023		   *@C00B4:
								mwrite<" ",0ah,0dh,0>
 000011F8		     1		.data		
 000011F8 20 0A 0D 00 00     1		??00A9 BYTE " ",0ah,0dh,0,0	
 00002023		     1		.code
 00002023  52		     1		push	edx
 00002024  BA 000011F8 R     1		mov	edx,OFFSET ??00A9
 00002029  E8 00000000 E     1		call	WriteString
 0000202E  5A		     1		pop	edx
								.endif
								mwrite<"	",0>
 0000202F 000011FD	     1		.data		
 000011FD 09 00 00	     1		??00AA BYTE "	",0,0	
 0000202F		     1		.code
 0000202F  52		     1		push	edx
 00002030  BA 000011FD R     1		mov	edx,OFFSET ??00AA
 00002035  E8 00000000 E     1		call	WriteString
 0000203A  5A		     1		pop	edx
 0000203B  E8 00000000 E					call writeint
 00002040  83 C6 04						add esi, type arr
 00002043  E2 C3					loop Lprint
						.endif
 00002045		   *@C00B2:
 00002045				LExit:
 00002045  C3					ret
 00002046			Inverse endp

 00002046			SystemOfLinearEquations proc
 00002046  E8 00000000 E	call crlf
					mwrite<"		1.For Equation with 2 Variables: ",0ah,0dh,0>
 00001200		     1		.data		
 00001200 09 09 31 2E 46     1		??00AB BYTE "		1.For Equation with 2 Variables: ",0ah,0dh,0,0	
	   6F 72 20 45 71
	   75 61 74 69 6F
	   6E 20 77 69 74
	   68 20 32 20 56
	   61 72 69 61 62
	   6C 65 73 3A 20
	   0A 0D 00 00
 0000204B		     1		.code
 0000204B  52		     1		push	edx
 0000204C  BA 00001200 R     1		mov	edx,OFFSET ??00AB
 00002051  E8 00000000 E     1		call	WriteString
 00002056  5A		     1		pop	edx
					mwrite<"		2.For Equations with 3 Variables: ",0ah,0dh,0>
 00001227		     1		.data		
 00001227 09 09 32 2E 46     1		??00AC BYTE "		2.For Equations with 3 Variables: ",0ah,0dh,0,0	
	   6F 72 20 45 71
	   75 61 74 69 6F
	   6E 73 20 77 69
	   74 68 20 33 20
	   56 61 72 69 61
	   62 6C 65 73 3A
	   20 0A 0D 00 00
 00002057		     1		.code
 00002057  52		     1		push	edx
 00002058  BA 00001227 R     1		mov	edx,OFFSET ??00AC
 0000205D  E8 00000000 E     1		call	WriteString
 00002062  5A		     1		pop	edx
					mwrite<"		Enter your Choice: ",0ah,0dh,0>
 0000124F		     1		.data		
 0000124F 09 09 45 6E 74     1		??00AD BYTE "		Enter your Choice: ",0ah,0dh,0,0	
	   65 72 20 79 6F
	   75 72 20 43 68
	   6F 69 63 65 3A
	   20 0A 0D 00 00
 00002063		     1		.code
 00002063  52		     1		push	edx
 00002064  BA 0000124F R     1		mov	edx,OFFSET ??00AD
 00002069  E8 00000000 E     1		call	WriteString
 0000206E  5A		     1		pop	edx
					mwrite<"---------------------------------------: ",0>
 00001268		     1		.data		
 00001268 2D 2D 2D 2D 2D     1		??00AE BYTE "---------------------------------------: ",0,0	
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 3A
	   20 00 00
 0000206F		     1		.code
 0000206F  52		     1		push	edx
 00002070  BA 00001268 R     1		mov	edx,OFFSET ??00AE
 00002075  E8 00000000 E     1		call	WriteString
 0000207A  5A		     1		pop	edx
 0000207B  E8 00000000 E		call readint
					.if eax==1
 00002080  83 F8 01	   *	    cmp    eax, 001h
 00002083  75 04	   *	    jne    @C00B6
 00002085  EB 07				jmp case1
					.else
 00002087  EB 05	   *	    jmp    @C00B8
 00002089		   *@C00B6:
 00002089  E9 0000020D				jmp case2
					.endif
 0000208E		   *@C00B8:
 0000208E				case1:

 0000208E  BE 00000000				mov esi,0
						mwrite<"Enter The Co-Effient of A1",0ah,0dh,0>
 00001293		     1		.data		
 00001293 45 6E 74 65 72     1		??00AF BYTE "Enter The Co-Effient of A1",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 2D 45 66
	   66 69 65 6E 74
	   20 6F 66 20 41
	   31 0A 0D 00 00
 00002093		     1		.code
 00002093  52		     1		push	edx
 00002094  BA 00001293 R     1		mov	edx,OFFSET ??00AF
 00002099  E8 00000000 E     1		call	WriteString
 0000209E  5A		     1		pop	edx
 0000209F  E8 00000000 E			call readint
 000020A4  A3 00000000 R			mov var1,eax
						mwrite<"Enter The Co-Effient of B1",0ah,0dh,0>
 000012B1		     1		.data		
 000012B1 45 6E 74 65 72     1		??00B0 BYTE "Enter The Co-Effient of B1",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 2D 45 66
	   66 69 65 6E 74
	   20 6F 66 20 42
	   31 0A 0D 00 00
 000020A9		     1		.code
 000020A9  52		     1		push	edx
 000020AA  BA 000012B1 R     1		mov	edx,OFFSET ??00B0
 000020AF  E8 00000000 E     1		call	WriteString
 000020B4  5A		     1		pop	edx
 000020B5  E8 00000000 E			call readint
 000020BA  A3 00000004 R			mov var2,eax
						mwrite<"Enter The Contant(c) of the Equation_1",0ah,0dh,0>
 000012CF		     1		.data		
 000012CF 45 6E 74 65 72     1		??00B1 BYTE "Enter The Contant(c) of the Equation_1",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 6E 74 61
	   6E 74 28 63 29
	   20 6F 66 20 74
	   68 65 20 45 71
	   75 61 74 69 6F
	   6E 5F 31 0A 0D
	   00 00
 000020BF		     1		.code
 000020BF  52		     1		push	edx
 000020C0  BA 000012CF R     1		mov	edx,OFFSET ??00B1
 000020C5  E8 00000000 E     1		call	WriteString
 000020CA  5A		     1		pop	edx
 000020CB  E8 00000000 E			call readint
 000020D0  A3 00000024 R			mov matrixb1,eax
						mwrite<"Enter The Co-Effient of A2",0ah,0dh,0>
 000012F9		     1		.data		
 000012F9 45 6E 74 65 72     1		??00B2 BYTE "Enter The Co-Effient of A2",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 2D 45 66
	   66 69 65 6E 74
	   20 6F 66 20 41
	   32 0A 0D 00 00
 000020D5		     1		.code
 000020D5  52		     1		push	edx
 000020D6  BA 000012F9 R     1		mov	edx,OFFSET ??00B2
 000020DB  E8 00000000 E     1		call	WriteString
 000020E0  5A		     1		pop	edx
 000020E1  E8 00000000 E			call readint
 000020E6  A3 00000008 R			mov var3,eax
						mwrite<"Enter The Co-Effient of B2",0ah,0dh,0>
 00001317		     1		.data		
 00001317 45 6E 74 65 72     1		??00B3 BYTE "Enter The Co-Effient of B2",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 2D 45 66
	   66 69 65 6E 74
	   20 6F 66 20 42
	   32 0A 0D 00 00
 000020EB		     1		.code
 000020EB  52		     1		push	edx
 000020EC  BA 00001317 R     1		mov	edx,OFFSET ??00B3
 000020F1  E8 00000000 E     1		call	WriteString
 000020F6  5A		     1		pop	edx
 000020F7  E8 00000000 E			call readint
 000020FC  A3 0000000C R			mov var4,eax
						mwrite<"Enter The Contant(c) of the Equation_2",0ah,0dh,0>
 00001335		     1		.data		
 00001335 45 6E 74 65 72     1		??00B4 BYTE "Enter The Contant(c) of the Equation_2",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 6E 74 61
	   6E 74 28 63 29
	   20 6F 66 20 74
	   68 65 20 45 71
	   75 61 74 69 6F
	   6E 5F 32 0A 0D
	   00 00
 00002101		     1		.code
 00002101  52		     1		push	edx
 00002102  BA 00001335 R     1		mov	edx,OFFSET ??00B4
 00002107  E8 00000000 E     1		call	WriteString
 0000210C  5A		     1		pop	edx
 0000210D  E8 00000000 E			call readint
 00002112  A3 00000028 R			mov matrixb2,eax


 00002117  BE 00000000				mov esi,0
 0000211C  A1 00000000 R			mov eax,var1
 00002121  89 86 00000234 R			mov arr[esi],eax
 00002127  A1 00000004 R			mov eax,var2
 0000212C  89 86 00000238 R			mov arr[esi+4],eax
 00002132  A1 00000008 R			mov eax,var3
 00002137  89 86 0000023C R			mov arr[esi+8],eax
 0000213D  A1 0000000C R			mov eax,var4
 00002142  89 86 00000240 R			mov arr[esi+12],eax

 00002148  BE 00000000				mov esi,0
 0000214D  A1 00000024 R			mov eax,matrixb1
 00002152  89 86 00000258 R			mov arr1[esi],eax
 00002158  A1 00000028 R			mov eax,matrixb2
 0000215D  89 86 0000025C R			mov arr1[esi+4],eax

 00002163  BE 00000000				mov esi,0
 00002168  8B 86 00000234 R			mov eax,arr[esi]
 0000216E  8B 9E 00000240 R			mov ebx,arr[esi+12]
 00002174  F7 E3				mul ebx
 00002176  50					push eax
 00002177  8B 86 00000238 R			mov eax,arr[esi+4]
 0000217D  8B 9E 0000023C R			mov ebx,arr[esi+8]
 00002183  F7 E3				mul ebx
 00002185  A3 00000000 R			mov var1,eax
 0000218A  58					pop eax
 0000218B  2B 05 00000000 R			sub eax,var1
 00002191  A3 00000000 R			mov var1,eax

 00002196  E8 00000000 E			call writeint
						.if eax==0
 0000219B  0B C0	   *	    or	eax, eax
 0000219D  75 16	   *	    jne    @C00B9
							mwrite<0ah,0dh,"As it is Singular Matrix So,solution Does not Exit",0ah,0dh,0>
 0000135F		     1		.data		
 0000135F 0A 0D 41 73 20     1		??00B5 BYTE 0ah,0dh,"As it is Singular Matrix So,solution Does not Exit",0ah,0dh,0,0	
	   69 74 20 69 73
	   20 53 69 6E 67
	   75 6C 61 72 20
	   4D 61 74 72 69
	   78 20 53 6F 2C
	   73 6F 6C 75 74
	   69 6F 6E 20 44
	   6F 65 73 20 6E
	   6F 74 20 45 78
	   69 74 0A 0D 00
	   00
 0000219F		     1		.code
 0000219F  52		     1		push	edx
 000021A0  BA 0000135F R     1		mov	edx,OFFSET ??00B5
 000021A5  E8 00000000 E     1		call	WriteString
 000021AA  5A		     1		pop	edx
 000021AB  E9 0000071E					jmp LExit
						.else
 000021B0  E9 000000E1	   *	    jmp    @C00BB
 000021B5		   *@C00B9:
 000021B5  BE 00000000					mov esi,0
 000021BA  8B 86 00000234 R				mov eax,arr[esi]
 000021C0  87 86 00000240 R				xchg eax,arr[esi+12]
 000021C6  89 86 00000234 R				mov arr[esi],eax
 000021CC  8B 86 00000238 R				mov eax,arr[esi+4]
 000021D2  F7 D8					neg eax
 000021D4  89 86 00000238 R				mov arr[esi+4],eax

 000021DA  8B 86 0000023C R				mov eax,arr[esi+8]
 000021E0  F7 D8					neg eax
 000021E2  89 86 0000023C R				mov arr[esi+8],eax

 000021E8  BE 00000000					mov esi,0
 000021ED  8B 86 00000234 R				mov eax,arr[esi]
 000021F3  8B 9E 00000258 R				mov ebx,arr1[esi]
 000021F9  F7 E3					mul ebx
 000021FB  A3 00000000 R				mov var1,eax
 00002200  8B 86 00000238 R				mov eax,arr[esi+4]
 00002206  8B 9E 0000025C R				mov ebx,arr1[esi+4]
 0000220C  F7 E3					mul ebx
 0000220E  03 05 00000000 R				add eax,var1
 00002214  50						push eax

 00002215  8B 86 0000023C R				mov eax,arr[esi+8]
 0000221B  8B 9E 00000258 R				mov ebx,arr1[esi]
 00002221  F7 E3					mul ebx
 00002223  A3 00000000 R				mov var1,eax
 00002228  8B 86 00000240 R				mov eax,arr[esi+12]
 0000222E  8B 9E 0000025C R				mov ebx,arr1[esi+4]
 00002234  F7 E3					mul ebx
 00002236  03 05 00000000 R				add eax,var1
 0000223C  50						push eax

 0000223D  BE 00000000					mov esi,0
 00002242  B9 00000002					mov ecx,2
 00002247						Lpop:
 00002247  58							pop eax
 00002248  89 86 00000234 R					mov arr[esi],eax
 0000224E  83 C6 04						add esi,type arr
 00002251  E2 F4					loop Lpop
							mwrite<"The Solution of the Given Equations is: ",0ah,0dh,0>
 00001397		     1		.data		
 00001397 54 68 65 20 53     1		??00B6 BYTE "The Solution of the Given Equations is: ",0ah,0dh,0,0	
	   6F 6C 75 74 69
	   6F 6E 20 6F 66
	   20 74 68 65 20
	   47 69 76 65 6E
	   20 45 71 75 61
	   74 69 6F 6E 73
	   20 69 73 3A 20
	   0A 0D 00 00
 00002253		     1		.code
 00002253  52		     1		push	edx
 00002254  BA 00001397 R     1		mov	edx,OFFSET ??00B6
 00002259  E8 00000000 E     1		call	WriteString
 0000225E  5A		     1		pop	edx
 0000225F  BE 00000004					mov esi,4
 00002264  B9 00000002					mov ecx,2
 00002269						Lprint:
 00002269  8B 86 00000234 R					mov eax,arr[esi]
								.if ecx==1
 0000226F  83 F9 01	   *	    cmp    ecx, 001h
 00002272  75 0C	   *	    jne    @C00BC
								mwrite<"	",0ah,0dh,0>
 000013C3		     1		.data		
 000013C3 09 0A 0D 00 00     1		??00B7 BYTE "	",0ah,0dh,0,0	
 00002274		     1		.code
 00002274  52		     1		push	edx
 00002275  BA 000013C3 R     1		mov	edx,OFFSET ??00B7
 0000227A  E8 00000000 E     1		call	WriteString
 0000227F  5A		     1		pop	edx
								.endif
								mwrite<"	",0>
 00002280 000013C8	     1		.data		
 000013C8 09 00 00	     1		??00B8 BYTE "	",0,0	
 00002280		     1		.code
 00002280  52		     1		push	edx
 00002281  BA 000013C8 R     1		mov	edx,OFFSET ??00B8
 00002286  E8 00000000 E     1		call	WriteString
 0000228B  5A		     1		pop	edx
 0000228C  E8 00000000 E					call writeint
 00002291  83 EE 04						sub esi,type arr
 00002294  E2 D3					loop Lprint
						.endif
 00002296		   *@C00BB:
 00002296  E9 00000633					jmp LExit
 0000229B				case2:
 0000229B  BE 00000000				mov esi,0
						mwrite<"Enter The Co-Effient of A1",0ah,0dh,0>
 000013CB		     1		.data		
 000013CB 45 6E 74 65 72     1		??00B9 BYTE "Enter The Co-Effient of A1",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 2D 45 66
	   66 69 65 6E 74
	   20 6F 66 20 41
	   31 0A 0D 00 00
 000022A0		     1		.code
 000022A0  52		     1		push	edx
 000022A1  BA 000013CB R     1		mov	edx,OFFSET ??00B9
 000022A6  E8 00000000 E     1		call	WriteString
 000022AB  5A		     1		pop	edx
 000022AC  E8 00000000 E			call readint
 000022B1  A3 00000000 R			mov var1,eax
						mwrite<"Enter The Co-Effient of B1",0ah,0dh,0>
 000013E9		     1		.data		
 000013E9 45 6E 74 65 72     1		??00BA BYTE "Enter The Co-Effient of B1",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 2D 45 66
	   66 69 65 6E 74
	   20 6F 66 20 42
	   31 0A 0D 00 00
 000022B6		     1		.code
 000022B6  52		     1		push	edx
 000022B7  BA 000013E9 R     1		mov	edx,OFFSET ??00BA
 000022BC  E8 00000000 E     1		call	WriteString
 000022C1  5A		     1		pop	edx
 000022C2  E8 00000000 E			call readint
						mwrite<"Enter The Co-Effient of c1",0ah,0dh,0>
 00001407		     1		.data		
 00001407 45 6E 74 65 72     1		??00BB BYTE "Enter The Co-Effient of c1",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 2D 45 66
	   66 69 65 6E 74
	   20 6F 66 20 63
	   31 0A 0D 00 00
 000022C7		     1		.code
 000022C7  52		     1		push	edx
 000022C8  BA 00001407 R     1		mov	edx,OFFSET ??00BB
 000022CD  E8 00000000 E     1		call	WriteString
 000022D2  5A		     1		pop	edx
 000022D3  E8 00000000 E			call readint
 000022D8  A3 00000008 R			mov var3,eax
						mwrite<"Enter The Contant(d1) of the Equation_1",0ah,0dh,0>
 00001425		     1		.data		
 00001425 45 6E 74 65 72     1		??00BC BYTE "Enter The Contant(d1) of the Equation_1",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 6E 74 61
	   6E 74 28 64 31
	   29 20 6F 66 20
	   74 68 65 20 45
	   71 75 61 74 69
	   6F 6E 5F 31 0A
	   0D 00 00
 000022DD		     1		.code
 000022DD  52		     1		push	edx
 000022DE  BA 00001425 R     1		mov	edx,OFFSET ??00BC
 000022E3  E8 00000000 E     1		call	WriteString
 000022E8  5A		     1		pop	edx
 000022E9  E8 00000000 E			call readint
 000022EE  A3 00000024 R			mov matrixb1,eax
						mwrite<"Enter The Co-Effient of A2",0ah,0dh,0>
 00001450		     1		.data		
 00001450 45 6E 74 65 72     1		??00BD BYTE "Enter The Co-Effient of A2",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 2D 45 66
	   66 69 65 6E 74
	   20 6F 66 20 41
	   32 0A 0D 00 00
 000022F3		     1		.code
 000022F3  52		     1		push	edx
 000022F4  BA 00001450 R     1		mov	edx,OFFSET ??00BD
 000022F9  E8 00000000 E     1		call	WriteString
 000022FE  5A		     1		pop	edx
 000022FF  E8 00000000 E			call readint
 00002304  A3 0000000C R			mov var4,eax
						mwrite<"Enter The Co-Effient of B2",0ah,0dh,0>
 0000146E		     1		.data		
 0000146E 45 6E 74 65 72     1		??00BE BYTE "Enter The Co-Effient of B2",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 2D 45 66
	   66 69 65 6E 74
	   20 6F 66 20 42
	   32 0A 0D 00 00
 00002309		     1		.code
 00002309  52		     1		push	edx
 0000230A  BA 0000146E R     1		mov	edx,OFFSET ??00BE
 0000230F  E8 00000000 E     1		call	WriteString
 00002314  5A		     1		pop	edx
 00002315  E8 00000000 E			call readint
 0000231A  A3 00000010 R			mov var5,eax
						mwrite<"Enter The Co-Effient of C2",0ah,0dh,0>
 0000148C		     1		.data		
 0000148C 45 6E 74 65 72     1		??00BF BYTE "Enter The Co-Effient of C2",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 2D 45 66
	   66 69 65 6E 74
	   20 6F 66 20 43
	   32 0A 0D 00 00
 0000231F		     1		.code
 0000231F  52		     1		push	edx
 00002320  BA 0000148C R     1		mov	edx,OFFSET ??00BF
 00002325  E8 00000000 E     1		call	WriteString
 0000232A  5A		     1		pop	edx
 0000232B  E8 00000000 E			call readint
 00002330  A3 00000014 R			mov var6,eax
						mwrite<"Enter The Contant(d2) of the Equation_2",0ah,0dh,0>
 000014AA		     1		.data		
 000014AA 45 6E 74 65 72     1		??00C0 BYTE "Enter The Contant(d2) of the Equation_2",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 6E 74 61
	   6E 74 28 64 32
	   29 20 6F 66 20
	   74 68 65 20 45
	   71 75 61 74 69
	   6F 6E 5F 32 0A
	   0D 00 00
 00002335		     1		.code
 00002335  52		     1		push	edx
 00002336  BA 000014AA R     1		mov	edx,OFFSET ??00C0
 0000233B  E8 00000000 E     1		call	WriteString
 00002340  5A		     1		pop	edx
 00002341  E8 00000000 E			call readint
 00002346  A3 00000028 R			mov matrixb2,eax
		mwrite<"Enter The Co-Effient of A3",0ah,0dh,0>
 000014D5		     1		.data		
 000014D5 45 6E 74 65 72     1		??00C1 BYTE "Enter The Co-Effient of A3",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 2D 45 66
	   66 69 65 6E 74
	   20 6F 66 20 41
	   33 0A 0D 00 00
 0000234B		     1		.code
 0000234B  52		     1		push	edx
 0000234C  BA 000014D5 R     1		mov	edx,OFFSET ??00C1
 00002351  E8 00000000 E     1		call	WriteString
 00002356  5A		     1		pop	edx
 00002357  E8 00000000 E			call readint
 0000235C  A3 0000000C R			mov var4,eax
						mwrite<"Enter The Co-Effient of B3",0ah,0dh,0>
 000014F3		     1		.data		
 000014F3 45 6E 74 65 72     1		??00C2 BYTE "Enter The Co-Effient of B3",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 2D 45 66
	   66 69 65 6E 74
	   20 6F 66 20 42
	   33 0A 0D 00 00
 00002361		     1		.code
 00002361  52		     1		push	edx
 00002362  BA 000014F3 R     1		mov	edx,OFFSET ??00C2
 00002367  E8 00000000 E     1		call	WriteString
 0000236C  5A		     1		pop	edx
 0000236D  E8 00000000 E			call readint
 00002372  A3 00000010 R			mov var5,eax
						mwrite<"Enter The Co-Effient of C3",0ah,0dh,0>
 00001511		     1		.data		
 00001511 45 6E 74 65 72     1		??00C3 BYTE "Enter The Co-Effient of C3",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 2D 45 66
	   66 69 65 6E 74
	   20 6F 66 20 43
	   33 0A 0D 00 00
 00002377		     1		.code
 00002377  52		     1		push	edx
 00002378  BA 00001511 R     1		mov	edx,OFFSET ??00C3
 0000237D  E8 00000000 E     1		call	WriteString
 00002382  5A		     1		pop	edx
 00002383  E8 00000000 E			call readint
 00002388  A3 00000014 R			mov var6,eax
						mwrite<"Enter The Contant(d3) of the Equation_3",0ah,0dh,0>
 0000152F		     1		.data		
 0000152F 45 6E 74 65 72     1		??00C4 BYTE "Enter The Contant(d3) of the Equation_3",0ah,0dh,0,0	
	   20 54 68 65 20
	   43 6F 6E 74 61
	   6E 74 28 64 33
	   29 20 6F 66 20
	   74 68 65 20 45
	   71 75 61 74 69
	   6F 6E 5F 33 0A
	   0D 00 00
 0000238D		     1		.code
 0000238D  52		     1		push	edx
 0000238E  BA 0000152F R     1		mov	edx,OFFSET ??00C4
 00002393  E8 00000000 E     1		call	WriteString
 00002398  5A		     1		pop	edx
 00002399  E8 00000000 E			call readint
 0000239E  A3 0000002C R			mov matrixb3,eax

 000023A3  BE 00000000				mov esi,0
 000023A8  A1 00000000 R			mov eax,var1
 000023AD  89 86 00000234 R			mov arr[esi],eax
 000023B3  A1 00000004 R			mov eax,var2
 000023B8  89 86 00000238 R			mov arr[esi+4],eax
 000023BE  A1 00000008 R			mov eax,var3
 000023C3  89 86 0000023C R			mov arr[esi+8],eax
 000023C9  A1 0000000C R			mov eax,var4
 000023CE  89 86 00000240 R			mov arr[esi+12],eax
 000023D4  A1 00000010 R			mov eax,var5
 000023D9  89 86 00000244 R			mov arr[esi+16],eax
 000023DF  A1 00000014 R			mov eax,var6
 000023E4  89 86 00000248 R			mov arr[esi+20],eax
 000023EA  A1 00000018 R			mov eax,var7
 000023EF  89 86 0000024C R			mov arr[esi+24],eax
 000023F5  A1 0000001C R			mov eax,var8
 000023FA  89 86 00000250 R			mov arr[esi+28],eax
 00002400  A1 00000020 R			mov eax,var9
 00002405  89 86 00000254 R			mov arr[esi+32],eax

 0000240B  BE 00000000				mov esi,0
 00002410  A1 00000024 R			mov eax,matrixb1
 00002415  89 86 00000258 R			mov arr1[esi],eax
 0000241B  A1 00000028 R			mov eax,matrixb2
 00002420  89 86 0000025C R			mov arr1[esi+4],eax
 00002426  A1 0000002C R			mov eax,matrixb3
 0000242B  89 86 0000023C R			mov arr[esi+8],eax



 00002431  BE 00000000				mov esi,0
 00002436  8B 86 00000234 R			mov eax,arr[esi]
 0000243C  A3 00000000 R			mov var1,eax
 00002441  8B 86 00000244 R			mov eax,arr[esi+16]
 00002447  8B 9E 00000254 R			mov ebx,arr[esi+32]
 0000244D  F7 E3				mul ebx
 0000244F  A3 00000004 R			mov var2,eax
 00002454  8B 86 00000248 R			mov eax,arr[esi+20]
 0000245A  8B 9E 00000250 R			mov ebx,arr[esi+28]
 00002460  F7 E3				mul ebx
 00002462  A3 00000008 R			mov var3,eax
 00002467  A1 00000004 R			mov eax,var2
 0000246C  2B 05 00000008 R			sub eax,var3
 00002472  F7 25 00000000 R			mul var1
 00002478  50					push eax

 00002479  8B 86 00000238 R			mov eax,arr[esi+4]
 0000247F  F7 D8				neg eax
 00002481  A3 00000000 R			mov var1,eax
 00002486  8B 86 00000240 R			mov eax,arr[esi+12]
 0000248C  8B 9E 00000254 R			mov ebx,arr[esi+32]
 00002492  F7 E3				mul ebx
 00002494  A3 00000004 R			mov var2,eax
 00002499  8B 86 00000248 R			mov eax,arr[esi+20]
 0000249F  8B 9E 0000024C R			mov ebx,arr[esi+24]
 000024A5  F7 E3				mul ebx
 000024A7  A3 00000008 R			mov var3,eax
 000024AC  A1 00000004 R			mov eax,var2
 000024B1  2B 05 00000008 R			sub eax,var3
 000024B7  F7 25 00000000 R			mul var1
 000024BD  50					push eax

 000024BE  8B 86 0000023C R			mov eax,arr[esi+8]
 000024C4  A3 00000000 R			mov var1,eax
 000024C9  8B 86 00000240 R			mov eax,arr[esi+12]
 000024CF  8B 9E 00000250 R			mov ebx,arr[esi+28]
 000024D5  F7 E3				mul ebx
 000024D7  A3 00000004 R			mov var2,eax
 000024DC  8B 86 00000244 R			mov eax,arr[esi+16]
 000024E2  8B 9E 0000024C R			mov ebx,arr[esi+24]
 000024E8  F7 E3				mul ebx
 000024EA  A3 00000008 R			mov var3,eax
 000024EF  A1 00000004 R			mov eax,var2
 000024F4  2B 05 00000008 R			sub eax,var3
 000024FA  F7 25 00000000 R			mul var1
 00002500  A3 00000000 R			mov var1,eax
 00002505  58					pop eax
 00002506  A3 00000004 R			mov var2,eax
 0000250B  58					pop eax
 0000250C  03 05 00000004 R			add eax,var2
 00002512  03 05 00000000 R			add eax,var1
 00002518  E8 00000000 E			call writeint

						.if eax==0
 0000251D  0B C0	   *	    or	eax, eax
 0000251F  75 16	   *	    jne    @C00BE
							mwrite<0ah,0dh,"As it is Singular Matrix So,solution Does not Exit",0ah,0dh,0>
 0000155A		     1		.data		
 0000155A 0A 0D 41 73 20     1		??00C5 BYTE 0ah,0dh,"As it is Singular Matrix So,solution Does not Exit",0ah,0dh,0,0	
	   69 74 20 69 73
	   20 53 69 6E 67
	   75 6C 61 72 20
	   4D 61 74 72 69
	   78 20 53 6F 2C
	   73 6F 6C 75 74
	   69 6F 6E 20 44
	   6F 65 73 20 6E
	   6F 74 20 45 78
	   69 74 0A 0D 00
	   00
 00002521		     1		.code
 00002521  52		     1		push	edx
 00002522  BA 0000155A R     1		mov	edx,OFFSET ??00C5
 00002527  E8 00000000 E     1		call	WriteString
 0000252C  5A		     1		pop	edx
 0000252D  E9 0000039C					jmp LExit
						.else
 00002532  E9 00000397	   *	    jmp    @C00C0
 00002537		   *@C00BE:
 00002537  50						push eax

 00002538  BE 00000000					mov esi,0
 0000253D  8B 86 00000244 R				mov eax,arr[esi+16]
 00002543  8B 9E 00000254 R				mov ebx,arr[esi+32]
 00002549  F7 E3					mul ebx
 0000254B  A3 00000000 R				mov var1,eax
 00002550  8B 86 00000248 R				mov eax,arr[esi+20]
 00002556  8B 9E 00000250 R				mov ebx,arr[esi+28]
 0000255C  F7 E3					mul ebx
 0000255E  A3 00000004 R				mov var2,eax
 00002563  A1 00000000 R				mov eax,var1
 00002568  2B 05 00000004 R				sub eax,var2
 0000256E  50						push eax

							;calculating 2nd Cofector
 0000256F  8B 86 00000240 R				mov eax,arr[esi+12]
 00002575  8B 9E 00000254 R				mov ebx,arr[esi+32]
 0000257B  F7 E3					mul ebx
 0000257D  A3 00000000 R				mov var1,eax
 00002582  8B 86 00000248 R				mov eax,arr[esi+20]
 00002588  8B 9E 0000024C R				mov ebx,arr[esi+24]
 0000258E  F7 E3					mul ebx
 00002590  A3 00000004 R				mov var2,eax
 00002595  A1 00000000 R				mov eax,var1
 0000259A  2B 05 00000004 R				sub eax,var2
 000025A0  F7 D8					neg eax
 000025A2  50						push eax

							;calculating 3rd Cofector
 000025A3  8B 86 00000240 R				mov eax,arr[esi+12]
 000025A9  8B 9E 00000250 R				mov ebx,arr[esi+28]
 000025AF  F7 E3					mul ebx
 000025B1  A3 00000000 R				mov var1,eax
 000025B6  8B 86 00000244 R				mov eax,arr[esi+16]
 000025BC  8B 9E 0000024C R				mov ebx,arr[esi+24]
 000025C2  F7 E3					mul ebx
 000025C4  A3 00000004 R				mov var2,eax
 000025C9  A1 00000000 R				mov eax,var1
 000025CE  2B 05 00000004 R				sub eax,var2
 000025D4  50						push eax

							;calculating 4rth Cofector
 000025D5  8B 86 00000238 R				mov eax,arr[esi+4]
 000025DB  8B 9E 00000254 R				mov ebx,arr[esi+32]
 000025E1  F7 E3					mul ebx
 000025E3  A3 00000000 R				mov var1,eax
 000025E8  8B 86 0000023C R				mov eax,arr[esi+8]
					
 000025EE  8B 9E 00000250 R				mov ebx,arr[esi+28]
 000025F4  F7 E3					mul ebx
 000025F6  A3 00000004 R				mov var2,eax
 000025FB  A1 00000000 R				mov eax,var1
 00002600  2B 05 00000004 R				sub eax,var2
 00002606  F7 D8					neg eax
 00002608  50						push eax

							;calculating 5rth Cofector
 00002609  8B 86 00000234 R				mov eax,arr[esi]
 0000260F  8B 9E 00000254 R				mov ebx,arr[esi+32]
 00002615  F7 E3					mul ebx
 00002617  A3 00000000 R				mov var1,eax
 0000261C  8B 86 0000023C R				mov eax,arr[esi+8]
 00002622  8B 9E 0000024C R				mov ebx,arr[esi+24]
 00002628  F7 E3					mul ebx
 0000262A  A3 00000004 R				mov var2,eax
 0000262F  A1 00000000 R				mov eax,var1
 00002634  2B 05 00000004 R				sub eax,var2
 0000263A  50						push eax

							;calculating 6th Cofector
 0000263B  8B 86 00000234 R				mov eax,arr[esi]
 00002641  8B 9E 00000250 R				mov ebx,arr[esi+28]
 00002647  F7 E3					mul ebx
 00002649  A3 00000000 R				mov var1,eax
 0000264E  8B 86 00000238 R				mov eax,arr[esi+4]
 00002654  8B 9E 0000024C R				mov ebx,arr[esi+24]
 0000265A  F7 E3					mul ebx
 0000265C  A3 00000004 R				mov var2,eax
 00002661  A1 00000000 R				mov eax,var1
 00002666  2B 05 00000004 R				sub eax,var2
 0000266C  F7 D8					neg eax
 0000266E  50						push eax

							;calculating 7th Cofector
 0000266F  8B 86 00000238 R				mov eax,arr[esi+4]
 00002675  8B 9E 00000248 R				mov ebx,arr[esi+20]
 0000267B  F7 E3					mul ebx
 0000267D  A3 00000000 R				mov var1,eax
 00002682  8B 86 0000023C R				mov eax,arr[esi+8]
 00002688  8B 9E 00000244 R				mov ebx,arr[esi+16]
 0000268E  F7 E3					mul ebx
 00002690  A3 00000004 R				mov var2,eax
 00002695  A1 00000000 R				mov eax,var1
 0000269A  2B 05 00000004 R				sub eax,var2
 000026A0  50						push eax

							;calculating 8th Cofector

 000026A1  8B 86 00000234 R				mov eax,arr[esi]
 000026A7  8B 9E 00000248 R				mov ebx,arr[esi+20]
 000026AD  F7 E3					mul ebx
 000026AF  A3 00000000 R				mov var1,eax
 000026B4  8B 86 0000023C R				mov eax,arr[esi+8]
 000026BA  8B 9E 00000240 R				mov ebx,arr[esi+12]
 000026C0  F7 E3					mul ebx
 000026C2  A3 00000004 R				mov var2,eax
 000026C7  A1 00000000 R				mov eax,var1
 000026CC  2B 05 00000004 R				sub eax,var2
 000026D2  F7 D8					neg eax
 000026D4  50						push eax

							;calculating 9th Cofector
 000026D5  8B 86 00000234 R				mov eax,arr[esi]
 000026DB  8B 9E 00000244 R				mov ebx,arr[esi+16]
 000026E1  F7 E3					mul ebx
 000026E3  A3 00000000 R				mov var1,eax
 000026E8  8B 86 00000238 R				mov eax,arr[esi+4]
 000026EE  8B 9E 00000240 R				mov ebx,arr[esi+12]
 000026F4  F7 E3					mul ebx
 000026F6  A3 00000004 R				mov var2,eax
 000026FB  A1 00000000 R				mov eax,var1
 00002700  2B 05 00000004 R				sub eax,var2
 00002706  50						push eax

 00002707  BE 00000000					mov esi,0
 0000270C  B9 00000009					mov ecx,9
 00002711						Lpop1:
 00002711  58							pop eax
 00002712  89 86 00000234 R					mov arr[esi],eax
 00002718  83 C6 04						add esi,type arr
 0000271B  E2 F4					loop Lpop1

 0000271D  BE 00000000					mov esi,0
 00002722  8B 86 00000234 R				mov eax,arr[esi]
 00002728  87 86 00000254 R				xchg eax,arr[esi+32]
 0000272E  89 86 00000234 R				mov arr[esi],eax
 00002734  BE 00000000					mov esi,0
 00002739  8B 86 00000238 R				mov eax,arr[esi+4]
 0000273F  87 86 00000248 R				xchg eax,arr[esi+20]
 00002745  89 86 00000238 R				mov arr[esi+4],eax
 0000274B  BE 00000000					mov esi,0
 00002750  8B 86 00000240 R				mov eax,arr[esi+12]
 00002756  87 86 00000250 R				xchg eax,arr[esi+28]
 0000275C  89 86 00000240 R				mov arr[esi+12],eax

 00002762  8F 05 00000000 R				pop var1

 00002768  BE 00000000					mov esi,0
 0000276D  B9 00000009					mov ecx,9
 00002772						Lprint1:
 00002772  8B 86 00000234 R					mov eax,arr[esi]
 00002778  BA 00000000						mov edx,0
 0000277D  F7 35 00000000 R					div var1
								.if ecx==6 || ecx==3
 00002783  83 F9 06	   *	    cmp    ecx, 006h
 00002786  74 05	   *	    je	@C00C2
 00002788  83 F9 03	   *	    cmp    ecx, 003h
 0000278B  75 0C	   *	    jne    @C00C1
 0000278D		   *@C00C2:
								mwrite<" ",0ah,0dh,0>
 00001592		     1		.data		
 00001592 20 0A 0D 00 00     1		??00C6 BYTE " ",0ah,0dh,0,0	
 0000278D		     1		.code
 0000278D  52		     1		push	edx
 0000278E  BA 00001592 R     1		mov	edx,OFFSET ??00C6
 00002793  E8 00000000 E     1		call	WriteString
 00002798  5A		     1		pop	edx
								.endif
								mwrite<"	",0>
 00002799 00001597	     1		.data		
 00001597 09 00 00	     1		??00C7 BYTE "	",0,0	
 00002799		     1		.code
 00002799  52		     1		push	edx
 0000279A  BA 00001597 R     1		mov	edx,OFFSET ??00C7
 0000279F  E8 00000000 E     1		call	WriteString
 000027A4  5A		     1		pop	edx
 000027A5  83 C6 04						add esi, type arr
 000027A8  E2 C8					loop Lprint1

 000027AA  BE 00000000					mov esi,0
 000027AF  8B 86 00000234 R				mov eax,arr[esi]
 000027B5  8B 9E 00000258 R				mov ebx,arr1[esi]
 000027BB  F7 E3					mul ebx
 000027BD  A3 00000000 R				mov var1,eax
 000027C2  8B 86 00000238 R				mov eax,arr[esi+4]
 000027C8  8B 9E 0000025C R				mov ebx,arr1[esi+4]
 000027CE  F7 E3					mul ebx
 000027D0  A3 00000004 R				mov var2,eax
 000027D5  8B 86 0000023C R				mov eax,arr[esi+8]
 000027DB  8B 9E 00000264 R				mov ebx,arr1[esi+12]
 000027E1  F7 E3					mul ebx
 000027E3  03 05 00000000 R				add eax,var1
 000027E9  03 05 00000004 R				add eax,var2
 000027EF  50						push eax

 000027F0  BE 00000000					mov esi,0
 000027F5  8B 86 00000240 R				mov eax,arr[esi+12]
 000027FB  8B 9E 00000258 R				mov ebx,arr1[esi]
 00002801  F7 E3					mul ebx
 00002803  A3 00000000 R				mov var1,eax
 00002808  8B 86 00000244 R				mov eax,arr[esi+16]
 0000280E  8B 9E 0000025C R				mov ebx,arr1[esi+4]
 00002814  F7 E3					mul ebx
 00002816  A3 00000004 R				mov var2,eax
 0000281B  8B 86 00000248 R				mov eax,arr[esi+20]
 00002821  8B 9E 00000260 R				mov ebx,arr1[esi+8]
 00002827  F7 E3					mul ebx
 00002829  03 05 00000000 R				add eax,var1
 0000282F  03 05 00000004 R				add eax,var2
 00002835  50						push eax

									
 00002836  BE 00000000					mov esi,0
 0000283B  8B 86 0000024C R				mov eax,arr[esi+24]
 00002841  8B 9E 00000258 R				mov ebx,arr1[esi]
 00002847  F7 E3					mul ebx
 00002849  A3 00000000 R				mov var1,eax
 0000284E  8B 86 00000250 R				mov eax,arr[esi+28]
 00002854  8B 9E 0000025C R				mov ebx,arr1[esi+4]
 0000285A  F7 E3					mul ebx
 0000285C  A3 00000004 R				mov var2,eax
 00002861  8B 86 00000254 R				mov eax,arr[esi+32]
 00002867  8B 9E 00000260 R				mov ebx,arr1[esi+8]
 0000286D  F7 E3					mul ebx
 0000286F  03 05 00000000 R				add eax,var1
 00002875  03 05 00000004 R				add eax,var2
 0000287B  50						push eax

							
 0000287C  BE 00000000					mov esi,0
 00002881  B9 00000003					mov ecx,3
 00002886						Lpop2:
 00002886  58							pop eax
 00002887  89 86 00000234 R					mov arr[esi],eax
 0000288D  83 C6 04						add esi,type arr
 00002890  E2 F4					loop Lpop2

 00002892  BE 00000008					mov esi,8
 00002897  B9 00000003					mov ecx,3
 0000289C						Lprint2:
 0000289C  8B 86 00000234 R					mov eax,arr[esi]
								.if ecx==2 || ecx==1
 000028A2  83 F9 02	   *	    cmp    ecx, 002h
 000028A5  74 05	   *	    je	@C00C5
 000028A7  83 F9 01	   *	    cmp    ecx, 001h
 000028AA  75 0C	   *	    jne    @C00C4
 000028AC		   *@C00C5:
								mwrite<"	",0ah,0dh,0>
 0000159A		     1		.data		
 0000159A 09 0A 0D 00 00     1		??00C8 BYTE "	",0ah,0dh,0,0	
 000028AC		     1		.code
 000028AC  52		     1		push	edx
 000028AD  BA 0000159A R     1		mov	edx,OFFSET ??00C8
 000028B2  E8 00000000 E     1		call	WriteString
 000028B7  5A		     1		pop	edx
								.endif
								mwrite<"	",0>
 000028B8 0000159F	     1		.data		
 0000159F 09 00 00	     1		??00C9 BYTE "	",0,0	
 000028B8		     1		.code
 000028B8  52		     1		push	edx
 000028B9  BA 0000159F R     1		mov	edx,OFFSET ??00C9
 000028BE  E8 00000000 E     1		call	WriteString
 000028C3  5A		     1		pop	edx
 000028C4  E8 00000000 E					call writeint
 000028C9  83 EE 04						sub esi,type arr
 000028CC  E2 CE					loop Lprint2
						.endif
 000028CE		   *@C00C0:
 000028CE				LExit:
 000028CE  C3					ret
 000028CF			SystemOfLinearEquations endp
					
				end main



Microsoft (R) Macro Assembler Version 14.16.27027.1	    05/03/19 11:26:49
AddTwo.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

IsDefined  . . . . . . . . . . .	Func
Startup  . . . . . . . . . . . .	Proc
mDumpMem . . . . . . . . . . . .	Proc
mDump  . . . . . . . . . . . . .	Proc
mGotoxy  . . . . . . . . . . . .	Proc
mReadString  . . . . . . . . . .	Proc
mShowRegister  . . . . . . . . .	Proc
mShow  . . . . . . . . . . . . .	Proc
mWriteLn . . . . . . . . . . . .	Proc
mWriteSpace  . . . . . . . . . .	Proc
mWriteString . . . . . . . . . .	Proc
mWrite . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPosition . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  dwMaximumWindowSize  . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
FOCUS_EVENT_RECORD . . . . . . .	 00000004
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
FPU_ENVIRON  . . . . . . . . . .	 0000001C
  controlWord  . . . . . . . . .	 00000000	 Word
  statusWord . . . . . . . . . .	 00000004	 Word
  tagWord  . . . . . . . . . . .	 00000008	 Word
  instrPointerOffset . . . . . .	 0000000C	 DWord
  instrPointerSelector . . . . .	 00000010	 DWord
  operandPointerOffset . . . . .	 00000014	 DWord
  operandPointerSelector . . . .	 00000018	 Word
INPUT_RECORD . . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  Event  . . . . . . . . . . . .	 00000004	 XmmWord
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCommandId  . . . . . . . . .	 00000000	 DWord
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
KEY_EVENT_RECORD . . . . . . . .	 00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
MENU_EVENT_RECORD  . . . . . . .	 00000004
  dwCommandId  . . . . . . . . .	 00000000	 DWord
MOUSE_EVENT_RECORD . . . . . . .	 00000010
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
WINDOW_BUFFER_SIZE_RECORD  . . .	 00000004
  dwSize . . . . . . . . . . . .	 00000000	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 000015A2 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000028CF Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

AdjOf  . . . . . . . . . . . . .	P Near	 00000C86 _TEXT	Length= 00000367 Public STDCALL
  case1  . . . . . . . . . . . .	L Near	 00000CCE _TEXT	
  L11  . . . . . . . . . . . . .	L Near	 00000CE4 _TEXT	
  L12  . . . . . . . . . . . . .	L Near	 00000D2C _TEXT	
  case2  . . . . . . . . . . . .	L Near	 00000D5E _TEXT	
  L21  . . . . . . . . . . . . .	L Near	 00000D74 _TEXT	
  Lpop . . . . . . . . . . . . .	L Near	 00000F5D _TEXT	
  Lprint . . . . . . . . . . . .	L Near	 00000FB8 _TEXT	
  LExit  . . . . . . . . . . . .	L Near	 00000FEC _TEXT	
CloseFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Clrscr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateOutputFile . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Delay  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpMem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpRegs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMaxXY . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMseconds  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Gotoxy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Inverse  . . . . . . . . . . . .	P Near	 00001B6A _TEXT	Length= 000004DC Public STDCALL
  case1  . . . . . . . . . . . .	L Near	 00001BB2 _TEXT	
  L11  . . . . . . . . . . . . .	L Near	 00001BC8 _TEXT	
  L13  . . . . . . . . . . . . .	L Near	 00001C64 _TEXT	
  case2  . . . . . . . . . . . .	L Near	 00001CA1 _TEXT	
  L21  . . . . . . . . . . . . .	L Near	 00001CB7 _TEXT	
  Lpop . . . . . . . . . . . . .	L Near	 00001FA7 _TEXT	
  Lprint . . . . . . . . . . . .	L Near	 00002008 _TEXT	
  LExit  . . . . . . . . . . . .	L Near	 00002045 _TEXT	
IsDigit  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ModOf  . . . . . . . . . . . . .	P Near	 00000FED _TEXT	Length= 000001B8 Public STDCALL
  case1  . . . . . . . . . . . .	L Near	 00001032 _TEXT	
  L11  . . . . . . . . . . . . .	L Near	 00001048 _TEXT	
  case2  . . . . . . . . . . . .	L Near	 00001090 _TEXT	
  L21  . . . . . . . . . . . . .	L Near	 000010A6 _TEXT	
  LExit  . . . . . . . . . . . .	L Near	 000011A4 _TEXT	
MsgBoxAsk  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBox . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Multiplication . . . . . . . . .	P Near	 000016B2 _TEXT	Length= 000004B8 Public STDCALL
  case1  . . . . . . . . . . . .	L Near	 00001712 _TEXT	
  L11  . . . . . . . . . . . . .	L Near	 00001728 _TEXT	
  L12  . . . . . . . . . . . . .	L Near	 0000174E _TEXT	
  Lpop . . . . . . . . . . . . .	L Near	 0000180D _TEXT	
  Lprint . . . . . . . . . . . .	L Near	 00001823 _TEXT	
  case2  . . . . . . . . . . . .	L Near	 00001855 _TEXT	
  L21  . . . . . . . . . . . . .	L Near	 0000186B _TEXT	
  L22  . . . . . . . . . . . . .	L Near	 00001891 _TEXT	
  Lpop2  . . . . . . . . . . . .	L Near	 00001B21 _TEXT	
  Lprint2  . . . . . . . . . . .	L Near	 00001B37 _TEXT	
  LExit  . . . . . . . . . . . .	L Near	 00001B69 _TEXT	
OpenInputFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseDecimal32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseInteger32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Random32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFloat  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFromFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadHex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadInt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKeyFlush . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKey  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowFPUStack . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLength  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_copy . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_length . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_trim . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Subtraction  . . . . . . . . . .	P Near	 0000069E _TEXT	Length= 000005E8 Public STDCALL
  case1  . . . . . . . . . . . .	L Near	 00000736 _TEXT	
  L11  . . . . . . . . . . . . .	L Near	 0000074C _TEXT	
  L12  . . . . . . . . . . . . .	L Near	 00000772 _TEXT	
  L13  . . . . . . . . . . . . .	L Near	 00000798 _TEXT	
  case2  . . . . . . . . . . . .	L Near	 000007BF _TEXT	
  L21  . . . . . . . . . . . . .	L Near	 000007D5 _TEXT	
  L22  . . . . . . . . . . . . .	L Near	 000007FB _TEXT	
  L23  . . . . . . . . . . . . .	L Near	 00000821 _TEXT	
  case3  . . . . . . . . . . . .	L Near	 00000848 _TEXT	
  L31  . . . . . . . . . . . . .	L Near	 0000085E _TEXT	
  L32  . . . . . . . . . . . . .	L Near	 00000884 _TEXT	
  L33  . . . . . . . . . . . . .	L Near	 000008AA _TEXT	
  case4  . . . . . . . . . . . .	L Near	 000008D1 _TEXT	
  L41  . . . . . . . . . . . . .	L Near	 000008E7 _TEXT	
  L42  . . . . . . . . . . . . .	L Near	 0000090D _TEXT	
  L43  . . . . . . . . . . . . .	L Near	 00000933 _TEXT	
  case5  . . . . . . . . . . . .	L Near	 0000096B _TEXT	
  L51  . . . . . . . . . . . . .	L Near	 00000981 _TEXT	
  L52  . . . . . . . . . . . . .	L Near	 000009A7 _TEXT	
  L53  . . . . . . . . . . . . .	L Near	 000009CD _TEXT	
  case6  . . . . . . . . . . . .	L Near	 00000A05 _TEXT	
  L61  . . . . . . . . . . . . .	L Near	 00000A1B _TEXT	
  L62  . . . . . . . . . . . . .	L Near	 00000A41 _TEXT	
  L63  . . . . . . . . . . . . .	L Near	 00000A67 _TEXT	
  case7  . . . . . . . . . . . .	L Near	 00000A9F _TEXT	
  L71  . . . . . . . . . . . . .	L Near	 00000AB5 _TEXT	
  L72  . . . . . . . . . . . . .	L Near	 00000ADB _TEXT	
  L73  . . . . . . . . . . . . .	L Near	 00000B01 _TEXT	
  case8  . . . . . . . . . . . .	L Near	 00000B3E _TEXT	
  L81  . . . . . . . . . . . . .	L Near	 00000B54 _TEXT	
  L82  . . . . . . . . . . . . .	L Near	 00000B7A _TEXT	
  L83  . . . . . . . . . . . . .	L Near	 00000BA0 _TEXT	
  case9  . . . . . . . . . . . .	L Near	 00000BDD _TEXT	
  L91  . . . . . . . . . . . . .	L Near	 00000BF3 _TEXT	
  L92  . . . . . . . . . . . . .	L Near	 00000C19 _TEXT	
  L93  . . . . . . . . . . . . .	L Near	 00000C3F _TEXT	
  LExit  . . . . . . . . . . . .	L Near	 00000C85 _TEXT	
Sum  . . . . . . . . . . . . . .	P Near	 000000B6 _TEXT	Length= 000005E8 Public STDCALL
  case1  . . . . . . . . . . . .	L Near	 0000014E _TEXT	
  L11  . . . . . . . . . . . . .	L Near	 00000164 _TEXT	
  L12  . . . . . . . . . . . . .	L Near	 0000018A _TEXT	
  L13  . . . . . . . . . . . . .	L Near	 000001B0 _TEXT	
  case2  . . . . . . . . . . . .	L Near	 000001D7 _TEXT	
  L21  . . . . . . . . . . . . .	L Near	 000001ED _TEXT	
  L22  . . . . . . . . . . . . .	L Near	 00000213 _TEXT	
  L23  . . . . . . . . . . . . .	L Near	 00000239 _TEXT	
  case3  . . . . . . . . . . . .	L Near	 00000260 _TEXT	
  L31  . . . . . . . . . . . . .	L Near	 00000276 _TEXT	
  L32  . . . . . . . . . . . . .	L Near	 0000029C _TEXT	
  L33  . . . . . . . . . . . . .	L Near	 000002C2 _TEXT	
  case4  . . . . . . . . . . . .	L Near	 000002E9 _TEXT	
  L41  . . . . . . . . . . . . .	L Near	 000002FF _TEXT	
  L42  . . . . . . . . . . . . .	L Near	 00000325 _TEXT	
  L43  . . . . . . . . . . . . .	L Near	 0000034B _TEXT	
  case5  . . . . . . . . . . . .	L Near	 00000383 _TEXT	
  L51  . . . . . . . . . . . . .	L Near	 00000399 _TEXT	
  L52  . . . . . . . . . . . . .	L Near	 000003BF _TEXT	
  L53  . . . . . . . . . . . . .	L Near	 000003E5 _TEXT	
  case6  . . . . . . . . . . . .	L Near	 0000041D _TEXT	
  L61  . . . . . . . . . . . . .	L Near	 00000433 _TEXT	
  L62  . . . . . . . . . . . . .	L Near	 00000459 _TEXT	
  L63  . . . . . . . . . . . . .	L Near	 0000047F _TEXT	
  case7  . . . . . . . . . . . .	L Near	 000004B7 _TEXT	
  L71  . . . . . . . . . . . . .	L Near	 000004CD _TEXT	
  L72  . . . . . . . . . . . . .	L Near	 000004F3 _TEXT	
  L73  . . . . . . . . . . . . .	L Near	 00000519 _TEXT	
  case8  . . . . . . . . . . . .	L Near	 00000556 _TEXT	
  L81  . . . . . . . . . . . . .	L Near	 0000056C _TEXT	
  L82  . . . . . . . . . . . . .	L Near	 00000592 _TEXT	
  L83  . . . . . . . . . . . . .	L Near	 000005B8 _TEXT	
  case9  . . . . . . . . . . . .	L Near	 000005F5 _TEXT	
  L91  . . . . . . . . . . . . .	L Near	 0000060B _TEXT	
  L92  . . . . . . . . . . . . .	L Near	 00000631 _TEXT	
  L93  . . . . . . . . . . . . .	L Near	 00000657 _TEXT	
  LExit  . . . . . . . . . . . .	L Near	 0000069D _TEXT	
SystemOfLinearEquations  . . . .	P Near	 00002046 _TEXT	Length= 00000889 Public STDCALL
  case1  . . . . . . . . . . . .	L Near	 0000208E _TEXT	
  Lpop . . . . . . . . . . . . .	L Near	 00002247 _TEXT	
  Lprint . . . . . . . . . . . .	L Near	 00002269 _TEXT	
  case2  . . . . . . . . . . . .	L Near	 0000229B _TEXT	
  Lpop1  . . . . . . . . . . . .	L Near	 00002711 _TEXT	
  Lprint1  . . . . . . . . . . .	L Near	 00002772 _TEXT	
  Lpop2  . . . . . . . . . . . .	L Near	 00002886 _TEXT	
  Lprint2  . . . . . . . . . . .	L Near	 0000289C _TEXT	
  LExit  . . . . . . . . . . . .	L Near	 000028CE _TEXT	
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Transpose  . . . . . . . . . . .	P Near	 000011A5 _TEXT	Length= 0000050D Public STDCALL
  case1  . . . . . . . . . . . .	L Near	 0000123D _TEXT	
  L11  . . . . . . . . . . . . .	L Near	 00001253 _TEXT	
  L12  . . . . . . . . . . . . .	L Near	 00001279 _TEXT	
  case2  . . . . . . . . . . . .	L Near	 00001297 _TEXT	
  L21  . . . . . . . . . . . . .	L Near	 000012AD _TEXT	
  L22  . . . . . . . . . . . . .	L Near	 000012D3 _TEXT	
  case3  . . . . . . . . . . . .	L Near	 00001305 _TEXT	
  L31  . . . . . . . . . . . . .	L Near	 0000131B _TEXT	
  L32  . . . . . . . . . . . . .	L Near	 00001341 _TEXT	
  case4  . . . . . . . . . . . .	L Near	 00001378 _TEXT	
  L41  . . . . . . . . . . . . .	L Near	 0000138E _TEXT	
  L42  . . . . . . . . . . . . .	L Near	 000013B4 _TEXT	
  case5  . . . . . . . . . . . .	L Near	 000013D5 _TEXT	
  L51  . . . . . . . . . . . . .	L Near	 000013EB _TEXT	
  L52  . . . . . . . . . . . . .	L Near	 00001423 _TEXT	
  case6  . . . . . . . . . . . .	L Near	 00001455 _TEXT	
  L61  . . . . . . . . . . . . .	L Near	 0000146B _TEXT	
  L62  . . . . . . . . . . . . .	L Near	 000014C7 _TEXT	
  case7  . . . . . . . . . . . .	L Near	 000014FE _TEXT	
  L71  . . . . . . . . . . . . .	L Near	 00001514 _TEXT	
  L73  . . . . . . . . . . . . .	L Near	 0000153A _TEXT	
  case8  . . . . . . . . . . . .	L Near	 0000155B _TEXT	
  L81  . . . . . . . . . . . . .	L Near	 00001571 _TEXT	
  L83  . . . . . . . . . . . . .	L Near	 000015CD _TEXT	
  case9  . . . . . . . . . . . .	L Near	 000015FF _TEXT	
  L91  . . . . . . . . . . . . .	L Near	 00001615 _TEXT	
  L93  . . . . . . . . . . . . .	L Near	 00001671 _TEXT	
  LExit  . . . . . . . . . . . .	L Near	 000016B1 _TEXT	
WaitMsg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBinB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHexB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrameName  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrame  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteToFile  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteWindowsMsg  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
main . . . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 000000B6 Public STDCALL
printf . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
scanf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

??0000 . . . . . . . . . . . . .	Byte	 0000027C _DATA	
??0001 . . . . . . . . . . . . .	Byte	 00000293 _DATA	
??0002 . . . . . . . . . . . . .	Byte	 000002AC _DATA	
??0003 . . . . . . . . . . . . .	Byte	 000002CF _DATA	
??0004 . . . . . . . . . . . . .	Byte	 000002E6 _DATA	
??0005 . . . . . . . . . . . . .	Byte	 000002FF _DATA	
??0006 . . . . . . . . . . . . .	Byte	 00000322 _DATA	
??0007 . . . . . . . . . . . . .	Byte	 00000345 _DATA	
??0008 . . . . . . . . . . . . .	Byte	 00000364 _DATA	
??0009 . . . . . . . . . . . . .	Byte	 00000367 _DATA	
??000A . . . . . . . . . . . . .	Byte	 0000038A _DATA	
??000B . . . . . . . . . . . . .	Byte	 000003AD _DATA	
??000C . . . . . . . . . . . . .	Byte	 000003CC _DATA	
??000D . . . . . . . . . . . . .	Byte	 000003CF _DATA	
??000E . . . . . . . . . . . . .	Byte	 000003F2 _DATA	
??000F . . . . . . . . . . . . .	Byte	 00000415 _DATA	
??0010 . . . . . . . . . . . . .	Byte	 00000434 _DATA	
??0011 . . . . . . . . . . . . .	Byte	 00000437 _DATA	
??0012 . . . . . . . . . . . . .	Byte	 0000045A _DATA	
??0013 . . . . . . . . . . . . .	Byte	 0000047D _DATA	
??0014 . . . . . . . . . . . . .	Byte	 0000049C _DATA	
??0015 . . . . . . . . . . . . .	Byte	 000004A1 _DATA	
??0016 . . . . . . . . . . . . .	Byte	 000004A4 _DATA	
??0017 . . . . . . . . . . . . .	Byte	 000004C7 _DATA	
??0018 . . . . . . . . . . . . .	Byte	 000004EA _DATA	
??0019 . . . . . . . . . . . . .	Byte	 00000509 _DATA	
??001A . . . . . . . . . . . . .	Byte	 0000050E _DATA	
??001B . . . . . . . . . . . . .	Byte	 00000511 _DATA	
??001C . . . . . . . . . . . . .	Byte	 00000534 _DATA	
??001D . . . . . . . . . . . . .	Byte	 00000557 _DATA	
??001E . . . . . . . . . . . . .	Byte	 00000576 _DATA	
??001F . . . . . . . . . . . . .	Byte	 0000057B _DATA	
??0020 . . . . . . . . . . . . .	Byte	 0000057E _DATA	
??0021 . . . . . . . . . . . . .	Byte	 000005A1 _DATA	
??0022 . . . . . . . . . . . . .	Byte	 000005C4 _DATA	
??0023 . . . . . . . . . . . . .	Byte	 000005E3 _DATA	
??0024 . . . . . . . . . . . . .	Byte	 000005E8 _DATA	
??0025 . . . . . . . . . . . . .	Byte	 000005EB _DATA	
??0026 . . . . . . . . . . . . .	Byte	 0000060E _DATA	
??0027 . . . . . . . . . . . . .	Byte	 00000631 _DATA	
??0028 . . . . . . . . . . . . .	Byte	 00000650 _DATA	
??0029 . . . . . . . . . . . . .	Byte	 00000655 _DATA	
??002A . . . . . . . . . . . . .	Byte	 00000658 _DATA	
??002B . . . . . . . . . . . . .	Byte	 0000067B _DATA	
??002C . . . . . . . . . . . . .	Byte	 0000069E _DATA	
??002D . . . . . . . . . . . . .	Byte	 000006BD _DATA	
??002E . . . . . . . . . . . . .	Byte	 000006C0 _DATA	
??002F . . . . . . . . . . . . .	Byte	 000006C4 _DATA	
??0030 . . . . . . . . . . . . .	Byte	 000006C7 _DATA	
??0031 . . . . . . . . . . . . .	Byte	 000006DE _DATA	
??0032 . . . . . . . . . . . . .	Byte	 000006F7 _DATA	
??0033 . . . . . . . . . . . . .	Byte	 0000071A _DATA	
??0034 . . . . . . . . . . . . .	Byte	 0000073D _DATA	
??0035 . . . . . . . . . . . . .	Byte	 00000764 _DATA	
??0036 . . . . . . . . . . . . .	Byte	 00000767 _DATA	
??0037 . . . . . . . . . . . . .	Byte	 0000078A _DATA	
??0038 . . . . . . . . . . . . .	Byte	 000007AD _DATA	
??0039 . . . . . . . . . . . . .	Byte	 000007D4 _DATA	
??003A . . . . . . . . . . . . .	Byte	 000007D7 _DATA	
??003B . . . . . . . . . . . . .	Byte	 000007FA _DATA	
??003C . . . . . . . . . . . . .	Byte	 0000081D _DATA	
??003D . . . . . . . . . . . . .	Byte	 00000844 _DATA	
??003E . . . . . . . . . . . . .	Byte	 00000847 _DATA	
??003F . . . . . . . . . . . . .	Byte	 0000086A _DATA	
??0040 . . . . . . . . . . . . .	Byte	 0000088D _DATA	
??0041 . . . . . . . . . . . . .	Byte	 000008B4 _DATA	
??0042 . . . . . . . . . . . . .	Byte	 000008B9 _DATA	
??0043 . . . . . . . . . . . . .	Byte	 000008BC _DATA	
??0044 . . . . . . . . . . . . .	Byte	 000008DF _DATA	
??0045 . . . . . . . . . . . . .	Byte	 00000902 _DATA	
??0046 . . . . . . . . . . . . .	Byte	 00000929 _DATA	
??0047 . . . . . . . . . . . . .	Byte	 0000092E _DATA	
??0048 . . . . . . . . . . . . .	Byte	 00000931 _DATA	
??0049 . . . . . . . . . . . . .	Byte	 00000954 _DATA	
??004A . . . . . . . . . . . . .	Byte	 00000977 _DATA	
??004B . . . . . . . . . . . . .	Byte	 0000099E _DATA	
??004C . . . . . . . . . . . . .	Byte	 000009A3 _DATA	
??004D . . . . . . . . . . . . .	Byte	 000009A6 _DATA	
??004E . . . . . . . . . . . . .	Byte	 000009C9 _DATA	
??004F . . . . . . . . . . . . .	Byte	 000009EC _DATA	
??0050 . . . . . . . . . . . . .	Byte	 00000A13 _DATA	
??0051 . . . . . . . . . . . . .	Byte	 00000A18 _DATA	
??0052 . . . . . . . . . . . . .	Byte	 00000A1B _DATA	
??0053 . . . . . . . . . . . . .	Byte	 00000A3E _DATA	
??0054 . . . . . . . . . . . . .	Byte	 00000A61 _DATA	
??0055 . . . . . . . . . . . . .	Byte	 00000A88 _DATA	
??0056 . . . . . . . . . . . . .	Byte	 00000A8D _DATA	
??0057 . . . . . . . . . . . . .	Byte	 00000A90 _DATA	
??0058 . . . . . . . . . . . . .	Byte	 00000AB3 _DATA	
??0059 . . . . . . . . . . . . .	Byte	 00000AD6 _DATA	
??005A . . . . . . . . . . . . .	Byte	 00000AFD _DATA	
??005B . . . . . . . . . . . . .	Byte	 00000B00 _DATA	
??005C . . . . . . . . . . . . .	Byte	 00000B04 _DATA	
??005D . . . . . . . . . . . . .	Byte	 00000B07 _DATA	
??005E . . . . . . . . . . . . .	Byte	 00000B1E _DATA	
??005F . . . . . . . . . . . . .	Byte	 00000B35 _DATA	
??0060 . . . . . . . . . . . . .	Byte	 00000B4E _DATA	
??0061 . . . . . . . . . . . . .	Byte	 00000B79 _DATA	
??0062 . . . . . . . . . . . . .	Byte	 00000B99 _DATA	
??0063 . . . . . . . . . . . . .	Byte	 00000B9E _DATA	
??0064 . . . . . . . . . . . . .	Byte	 00000BA1 _DATA	
??0065 . . . . . . . . . . . . .	Byte	 00000BC1 _DATA	
??0066 . . . . . . . . . . . . .	Byte	 00000BC6 _DATA	
??0067 . . . . . . . . . . . . .	Byte	 00000BC9 _DATA	
??0068 . . . . . . . . . . . . .	Byte	 00000BE0 _DATA	
??0069 . . . . . . . . . . . . .	Byte	 00000BF7 _DATA	
??006A . . . . . . . . . . . . .	Byte	 00000C10 _DATA	
??006B . . . . . . . . . . . . .	Byte	 00000C3B _DATA	
??006C . . . . . . . . . . . . .	Byte	 00000C5B _DATA	
??006D . . . . . . . . . . . . .	Byte	 00000C7B _DATA	
??006E . . . . . . . . . . . . .	Byte	 00000C92 _DATA	
??006F . . . . . . . . . . . . .	Byte	 00000CAB _DATA	
??0070 . . . . . . . . . . . . .	Byte	 00000CCB _DATA	
??0071 . . . . . . . . . . . . .	Byte	 00000CF3 _DATA	
??0072 . . . . . . . . . . . . .	Byte	 00000CF6 _DATA	
??0073 . . . . . . . . . . . . .	Byte	 00000D17 _DATA	
??0074 . . . . . . . . . . . . .	Byte	 00000D3F _DATA	
??0075 . . . . . . . . . . . . .	Byte	 00000D44 _DATA	
??0076 . . . . . . . . . . . . .	Byte	 00000D47 _DATA	
??0077 . . . . . . . . . . . . .	Byte	 00000D68 _DATA	
??0078 . . . . . . . . . . . . .	Byte	 00000D90 _DATA	
??0079 . . . . . . . . . . . . .	Byte	 00000D95 _DATA	
??007A . . . . . . . . . . . . .	Byte	 00000D98 _DATA	
??007B . . . . . . . . . . . . .	Byte	 00000DB8 _DATA	
??007C . . . . . . . . . . . . .	Byte	 00000DE0 _DATA	
??007D . . . . . . . . . . . . .	Byte	 00000DE3 _DATA	
??007E . . . . . . . . . . . . .	Byte	 00000E03 _DATA	
??007F . . . . . . . . . . . . .	Byte	 00000E2B _DATA	
??0080 . . . . . . . . . . . . .	Byte	 00000E30 _DATA	
??0081 . . . . . . . . . . . . .	Byte	 00000E33 _DATA	
??0082 . . . . . . . . . . . . .	Byte	 00000E53 _DATA	
??0083 . . . . . . . . . . . . .	Byte	 00000E7B _DATA	
??0084 . . . . . . . . . . . . .	Byte	 00000E80 _DATA	
??0085 . . . . . . . . . . . . .	Byte	 00000E83 _DATA	
??0086 . . . . . . . . . . . . .	Byte	 00000EA3 _DATA	
??0087 . . . . . . . . . . . . .	Byte	 00000ECB _DATA	
??0088 . . . . . . . . . . . . .	Byte	 00000ECE _DATA	
??0089 . . . . . . . . . . . . .	Byte	 00000EEF _DATA	
??008A . . . . . . . . . . . . .	Byte	 00000F17 _DATA	
??008B . . . . . . . . . . . . .	Byte	 00000F1C _DATA	
??008C . . . . . . . . . . . . .	Byte	 00000F1F _DATA	
??008D . . . . . . . . . . . . .	Byte	 00000F42 _DATA	
??008E . . . . . . . . . . . . .	Byte	 00000F6B _DATA	
??008F . . . . . . . . . . . . .	Byte	 00000F6E _DATA	
??0090 . . . . . . . . . . . . .	Byte	 00000F72 _DATA	
??0091 . . . . . . . . . . . . .	Byte	 00000F75 _DATA	
??0092 . . . . . . . . . . . . .	Byte	 00000F91 _DATA	
??0093 . . . . . . . . . . . . .	Byte	 00000FBE _DATA	
??0094 . . . . . . . . . . . . .	Byte	 00000FD5 _DATA	
??0095 . . . . . . . . . . . . .	Byte	 00000FEC _DATA	
??0096 . . . . . . . . . . . . .	Byte	 00001005 _DATA	
??0097 . . . . . . . . . . . . .	Byte	 00001032 _DATA	
??0098 . . . . . . . . . . . . .	Byte	 00001055 _DATA	
??0099 . . . . . . . . . . . . .	Byte	 00001078 _DATA	
??009A . . . . . . . . . . . . .	Byte	 0000107D _DATA	
??009B . . . . . . . . . . . . .	Byte	 00001080 _DATA	
??009C . . . . . . . . . . . . .	Byte	 000010A3 _DATA	
??009D . . . . . . . . . . . . .	Byte	 000010C6 _DATA	
??009E . . . . . . . . . . . . .	Byte	 000010CB _DATA	
??009F . . . . . . . . . . . . .	Byte	 000010CE _DATA	
??00A0 . . . . . . . . . . . . .	Byte	 000010E5 _DATA	
??00A1 . . . . . . . . . . . . .	Byte	 000010FC _DATA	
??00A2 . . . . . . . . . . . . .	Byte	 00001115 _DATA	
??00A3 . . . . . . . . . . . . .	Byte	 00001140 _DATA	
??00A4 . . . . . . . . . . . . .	Byte	 00001160 _DATA	
??00A5 . . . . . . . . . . . . .	Byte	 00001198 _DATA	
??00A6 . . . . . . . . . . . . .	Byte	 0000119D _DATA	
??00A7 . . . . . . . . . . . . .	Byte	 000011A0 _DATA	
??00A8 . . . . . . . . . . . . .	Byte	 000011C0 _DATA	
??00A9 . . . . . . . . . . . . .	Byte	 000011F8 _DATA	
??00AA . . . . . . . . . . . . .	Byte	 000011FD _DATA	
??00AB . . . . . . . . . . . . .	Byte	 00001200 _DATA	
??00AC . . . . . . . . . . . . .	Byte	 00001227 _DATA	
??00AD . . . . . . . . . . . . .	Byte	 0000124F _DATA	
??00AE . . . . . . . . . . . . .	Byte	 00001268 _DATA	
??00AF . . . . . . . . . . . . .	Byte	 00001293 _DATA	
??00B0 . . . . . . . . . . . . .	Byte	 000012B1 _DATA	
??00B1 . . . . . . . . . . . . .	Byte	 000012CF _DATA	
??00B2 . . . . . . . . . . . . .	Byte	 000012F9 _DATA	
??00B3 . . . . . . . . . . . . .	Byte	 00001317 _DATA	
??00B4 . . . . . . . . . . . . .	Byte	 00001335 _DATA	
??00B5 . . . . . . . . . . . . .	Byte	 0000135F _DATA	
??00B6 . . . . . . . . . . . . .	Byte	 00001397 _DATA	
??00B7 . . . . . . . . . . . . .	Byte	 000013C3 _DATA	
??00B8 . . . . . . . . . . . . .	Byte	 000013C8 _DATA	
??00B9 . . . . . . . . . . . . .	Byte	 000013CB _DATA	
??00BA . . . . . . . . . . . . .	Byte	 000013E9 _DATA	
??00BB . . . . . . . . . . . . .	Byte	 00001407 _DATA	
??00BC . . . . . . . . . . . . .	Byte	 00001425 _DATA	
??00BD . . . . . . . . . . . . .	Byte	 00001450 _DATA	
??00BE . . . . . . . . . . . . .	Byte	 0000146E _DATA	
??00BF . . . . . . . . . . . . .	Byte	 0000148C _DATA	
??00C0 . . . . . . . . . . . . .	Byte	 000014AA _DATA	
??00C1 . . . . . . . . . . . . .	Byte	 000014D5 _DATA	
??00C2 . . . . . . . . . . . . .	Byte	 000014F3 _DATA	
??00C3 . . . . . . . . . . . . .	Byte	 00001511 _DATA	
??00C4 . . . . . . . . . . . . .	Byte	 0000152F _DATA	
??00C5 . . . . . . . . . . . . .	Byte	 0000155A _DATA	
??00C6 . . . . . . . . . . . . .	Byte	 00001592 _DATA	
??00C7 . . . . . . . . . . . . .	Byte	 00001597 _DATA	
??00C8 . . . . . . . . . . . . .	Byte	 0000159A _DATA	
??00C9 . . . . . . . . . . . . .	Byte	 0000159F _DATA	
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
ALT_MASK . . . . . . . . . . . .	Number	 00000003h   
CAPSLOCK_ON  . . . . . . . . . .	Number	 00000080h   
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CTRL_MASK  . . . . . . . . . . .	Number	 0000000Ch   
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
ENHANCED_KEY . . . . . . . . . .	Number	 00000100h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
FORMAT_MESSAGE_ALLOCATE_BUFFER .	Number	 00000100h   
FORMAT_MESSAGE_FROM_SYSTEM . . .	Number	 00001000h   
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HANDLE . . . . . . . . . . . . .	Text   	 DWORD
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
IDABORT  . . . . . . . . . . . .	Number	 00000003h   
IDCANCEL . . . . . . . . . . . .	Number	 00000002h   
IDCLOSE  . . . . . . . . . . . .	Number	 00000008h   
IDCONTINUE . . . . . . . . . . .	Number	 0000000Bh   
IDHELP . . . . . . . . . . . . .	Number	 00000009h   
IDIGNORE . . . . . . . . . . . .	Number	 00000005h   
IDNO . . . . . . . . . . . . . .	Number	 00000007h   
IDOK . . . . . . . . . . . . . .	Number	 00000001h   
IDRETRY  . . . . . . . . . . . .	Number	 00000004h   
IDTIMEOUT  . . . . . . . . . . .	Number	 00007D00h   
IDTRYAGAIN . . . . . . . . . . .	Number	 0000000Ah   
IDYES  . . . . . . . . . . . . .	Number	 00000006h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
KBDOWN_FLAG  . . . . . . . . . .	Number	 00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
KEY_MASKS  . . . . . . . . . . .	Number	 0000001Fh   
LEFT_ALT_PRESSED . . . . . . . .	Number	 00000002h   
LEFT_CTRL_PRESSED  . . . . . . .	Number	 00000008h   
MB_ABORTRETRYIGNORE  . . . . . .	Number	 00000002h   
MB_APPLMODAL . . . . . . . . . .	Number	 00000000h   
MB_CANCELTRYCONTINUE . . . . . .	Number	 00000006h   
MB_DEFBUTTON1  . . . . . . . . .	Number	 00000000h   
MB_DEFBUTTON2  . . . . . . . . .	Number	 00000100h   
MB_DEFBUTTON3  . . . . . . . . .	Number	 00000200h   
MB_DEFBUTTON4  . . . . . . . . .	Number	 00000300h   
MB_HELP  . . . . . . . . . . . .	Number	 00004000h   
MB_ICONASTERISK  . . . . . . . .	Number	 00000040h   
MB_ICONERROR . . . . . . . . . .	Number	 00000010h   
MB_ICONEXCLAMATION . . . . . . .	Number	 00000030h   
MB_ICONHAND  . . . . . . . . . .	Number	 00000010h   
MB_ICONINFORMATION . . . . . . .	Number	 00000040h   
MB_ICONQUESTION  . . . . . . . .	Number	 00000020h   
MB_ICONSTOP  . . . . . . . . . .	Number	 00000010h   
MB_ICONWARNING . . . . . . . . .	Number	 00000030h   
MB_OKCANCEL  . . . . . . . . . .	Number	 00000001h   
MB_OK  . . . . . . . . . . . . .	Number	 00000000h   
MB_RETRYCANCEL . . . . . . . . .	Number	 00000005h   
MB_SYSTEMMODAL . . . . . . . . .	Number	 00001000h   
MB_TASKMODAL . . . . . . . . . .	Number	 00002000h   
MB_USERICON  . . . . . . . . . .	Number	 00000080h   
MB_YESNOCANCEL . . . . . . . . .	Number	 00000003h   
MB_YESNO . . . . . . . . . . . .	Number	 00000004h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
Menu . . . . . . . . . . . . . .	Byte	 00000034 _DATA	
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
NULL . . . . . . . . . . . . . .	Number	 00000000h   
NUMLOCK_ON . . . . . . . . . . .	Number	 00000020h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
RIGHT_ALT_PRESSED  . . . . . . .	Number	 00000001h   
RIGHT_CTRL_PRESSED . . . . . . .	Number	 00000004h   
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
SCROLLLOCK_ON  . . . . . . . . .	Number	 00000040h   
SHIFT_MASK . . . . . . . . . . .	Number	 00000010h   
SHIFT_PRESSED  . . . . . . . . .	Number	 00000010h   
STD_ERROR_HANDLE . . . . . . . .	Number	 -0000000Ch   
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
TAB  . . . . . . . . . . . . . .	Number	 00000009h   
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
VK_11  . . . . . . . . . . . . .	Number	 000000BDh   
VK_12  . . . . . . . . . . . . .	Number	 000000BBh   
VK_ADD . . . . . . . . . . . . .	Number	 0000006Bh   
VK_BACK  . . . . . . . . . . . .	Number	 00000008h   
VK_CANCEL  . . . . . . . . . . .	Number	 00000003h   
VK_CAPITAL . . . . . . . . . . .	Number	 00000014h   
VK_CLEAR . . . . . . . . . . . .	Number	 0000000Ch   
VK_CONTROL . . . . . . . . . . .	Number	 00000011h   
VK_DECIMAL . . . . . . . . . . .	Number	 0000006Eh   
VK_DELETE  . . . . . . . . . . .	Number	 0000002Eh   
VK_DIVIDE  . . . . . . . . . . .	Number	 0000006Fh   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_END . . . . . . . . . . . . .	Number	 00000023h   
VK_ESCAPE  . . . . . . . . . . .	Number	 0000001Bh   
VK_EXECUTE . . . . . . . . . . .	Number	 0000002Bh   
VK_F10 . . . . . . . . . . . . .	Number	 00000079h   
VK_F11 . . . . . . . . . . . . .	Number	 0000007Ah   
VK_F12 . . . . . . . . . . . . .	Number	 0000007Bh   
VK_F13 . . . . . . . . . . . . .	Number	 0000007Ch   
VK_F14 . . . . . . . . . . . . .	Number	 0000007Dh   
VK_F15 . . . . . . . . . . . . .	Number	 0000007Eh   
VK_F16 . . . . . . . . . . . . .	Number	 0000007Fh   
VK_F17 . . . . . . . . . . . . .	Number	 00000080h   
VK_F18 . . . . . . . . . . . . .	Number	 00000081h   
VK_F19 . . . . . . . . . . . . .	Number	 00000082h   
VK_F1  . . . . . . . . . . . . .	Number	 00000070h   
VK_F20 . . . . . . . . . . . . .	Number	 00000083h   
VK_F21 . . . . . . . . . . . . .	Number	 00000084h   
VK_F22 . . . . . . . . . . . . .	Number	 00000085h   
VK_F23 . . . . . . . . . . . . .	Number	 00000086h   
VK_F24 . . . . . . . . . . . . .	Number	 00000087h   
VK_F2  . . . . . . . . . . . . .	Number	 00000071h   
VK_F3  . . . . . . . . . . . . .	Number	 00000072h   
VK_F4  . . . . . . . . . . . . .	Number	 00000073h   
VK_F5  . . . . . . . . . . . . .	Number	 00000074h   
VK_F6  . . . . . . . . . . . . .	Number	 00000075h   
VK_F7  . . . . . . . . . . . . .	Number	 00000076h   
VK_F8  . . . . . . . . . . . . .	Number	 00000077h   
VK_F9  . . . . . . . . . . . . .	Number	 00000078h   
VK_HELP  . . . . . . . . . . . .	Number	 0000002Fh   
VK_HOME  . . . . . . . . . . . .	Number	 00000024h   
VK_INSERT  . . . . . . . . . . .	Number	 0000002Dh   
VK_LBUTTON . . . . . . . . . . .	Number	 00000001h   
VK_LCONTROL  . . . . . . . . . .	Number	 000000A2h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_LMENU . . . . . . . . . . . .	Number	 000000A4h   
VK_LSHIFT  . . . . . . . . . . .	Number	 000000A0h   
VK_MENU  . . . . . . . . . . . .	Number	 00000012h   
VK_MULTIPLY  . . . . . . . . . .	Number	 0000006Ah   
VK_NEXT  . . . . . . . . . . . .	Number	 00000022h   
VK_NUMLOCK . . . . . . . . . . .	Number	 00000090h   
VK_NUMPAD0 . . . . . . . . . . .	Number	 00000060h   
VK_NUMPAD1 . . . . . . . . . . .	Number	 00000061h   
VK_NUMPAD2 . . . . . . . . . . .	Number	 00000062h   
VK_NUMPAD3 . . . . . . . . . . .	Number	 00000063h   
VK_NUMPAD4 . . . . . . . . . . .	Number	 00000064h   
VK_NUMPAD5 . . . . . . . . . . .	Number	 00000065h   
VK_NUMPAD6 . . . . . . . . . . .	Number	 00000066h   
VK_NUMPAD7 . . . . . . . . . . .	Number	 00000067h   
VK_NUMPAD8 . . . . . . . . . . .	Number	 00000068h   
VK_NUMPAD9 . . . . . . . . . . .	Number	 00000069h   
VK_PAUSE . . . . . . . . . . . .	Number	 00000013h   
VK_PRINT . . . . . . . . . . . .	Number	 0000002Ah   
VK_PRIOR . . . . . . . . . . . .	Number	 00000021h   
VK_RBUTTON . . . . . . . . . . .	Number	 00000002h   
VK_RCONTROL  . . . . . . . . . .	Number	 000000A3h   
VK_RETURN  . . . . . . . . . . .	Number	 0000000Dh   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_RMENU . . . . . . . . . . . .	Number	 000000A5h   
VK_RSHIFT  . . . . . . . . . . .	Number	 000000A1h   
VK_SCROLL  . . . . . . . . . . .	Number	 00000091h   
VK_SEPARATER . . . . . . . . . .	Number	 0000006Ch   
VK_SHIFT . . . . . . . . . . . .	Number	 00000010h   
VK_SNAPSHOT  . . . . . . . . . .	Number	 0000002Ch   
VK_SPACE . . . . . . . . . . . .	Number	 00000020h   
VK_SUBTRACT  . . . . . . . . . .	Number	 0000006Dh   
VK_TAB . . . . . . . . . . . . .	Number	 00000009h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
arr1 . . . . . . . . . . . . . .	DWord	 00000258 _DATA	
arr  . . . . . . . . . . . . . .	DWord	 00000234 _DATA	
black  . . . . . . . . . . . . .	Number	 00000000h   
blue . . . . . . . . . . . . . .	Number	 00000001h   
brown  . . . . . . . . . . . . .	Number	 00000006h   
cyan . . . . . . . . . . . . . .	Number	 00000003h   
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
magenta  . . . . . . . . . . . .	Number	 00000005h   
mainLabel  . . . . . . . . . . .	L Near	 00000000 _TEXT	
matrixb1 . . . . . . . . . . . .	DWord	 00000024 _DATA	
matrixb2 . . . . . . . . . . . .	DWord	 00000028 _DATA	
matrixb3 . . . . . . . . . . . .	DWord	 0000002C _DATA	
red  . . . . . . . . . . . . . .	Number	 00000004h   
selectString . . . . . . . . . .	Byte	 00000166 _DATA	
temprary . . . . . . . . . . . .	DWord	 00000030 _DATA	
var1 . . . . . . . . . . . . . .	DWord	 00000000 _DATA	
var2 . . . . . . . . . . . . . .	DWord	 00000004 _DATA	
var3 . . . . . . . . . . . . . .	DWord	 00000008 _DATA	
var4 . . . . . . . . . . . . . .	DWord	 0000000C _DATA	
var5 . . . . . . . . . . . . . .	DWord	 00000010 _DATA	
var6 . . . . . . . . . . . . . .	DWord	 00000014 _DATA	
var7 . . . . . . . . . . . . . .	DWord	 00000018 _DATA	
var8 . . . . . . . . . . . . . .	DWord	 0000001C _DATA	
var9 . . . . . . . . . . . . . .	DWord	 00000020 _DATA	
white  . . . . . . . . . . . . .	Number	 0000000Fh   
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   0 Warnings
	   0 Errors
